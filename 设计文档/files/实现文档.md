### 1.1.3 后端结构

后端使用Django框架实现。文件结构如下：

* **myapp**

  * **migrations**

    这个文件夹中是Django生成的数据库迁移代码，用于修改模型类后将修改执行到数据库。

  * **models.py**

    该文件定义了模型类，对应数据库的表，具体内容间本文档第二部分。

  * **url.py**

    该文件定义路由，通过设置文件中的路由，可以将不同的请求发送到不同的视图函数中进行处理。

  * **views.py**

    该文件定义视图函数，通过与数据模型进行交互，实现项目的相关功能。

* **backend**

  后端基本文件，用于进行一些配置，主要有Django框架生成。

* **manage.py**

  脚本，用于后端的部署、数据库的迁移等。

## 二、数据库基本表的定义

数据库共包含10个实体，11张表，采用Django提供的数据库访问接口实现数据库表的定义以及访问

### 2.1 用户管理部分

这部分内容有关用户的管理，主要包括用户的登录、注册、修改密码等功能。该系统中有三类用户，分别为学生、家教和管理员，其中管理员无法注册，只能由超级管理员（网站管理者）手动添加。考虑到老师和学生具有某些共同的性质（例如账号和密码），但是又有一些不同的属性（例如学生有成绩，家教有学生评分等），因此我们将Student和Tutor抽象为User统一管理，通过identity字段区分学生和家教，并通过**user_id**将User与其他表关联。

```python
# 用户表 BCNF
class User(models.Model):
    # 主码、主属性
    user_id = models.BigAutoField(primary_key=True)
    # 主属性
    username = models.CharField(max_length=255)
    password = models.CharField(max_length=255)
    identity = models.IntegerField()  # 0: 管理员,1: 家教, 2: 学生
    registration_date = models.DateField()

    def __str__(self):
        return self.username
    
    class Meta:
        ordering = ['-registration_date']
```

这种关系的设计可以在不需要继承的前提下使得学生和家教的共同属性可以在User表中维护，而不需要在Student和Tutor中重复定义。同时，这种设计也使得我们可以方便地通过user_id找到对应的学生或家教。

### Student

| 属性名  | 数据类型 | 备注         |
| ------- | -------- | ------------ |
| user_id | int      | 主码、主属性 |
| age     | int      | -            |
| gender  | int      | 0：男 1：女  |
| contact | varchar  | 主属性       |
| email   | email    | 主属性       |
| grade   | int      | -            |

```python
# 学生表 BCNF
class Student(models.Model):
    # 主码、主属性
    user_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='user_id_student')
    age = models.IntegerField(blank=True,null=True)
    gender = models.CharField(max_length=255,blank=True,null=True)
    # 主属性
    telephone = models.CharField(max_length=255,null=True,blank=True)
    # 主属性
    email = models.EmailField(max_length=255,blank=True,null=True)
    grade = models.CharField(max_length=255,blank=True,null=True)
    address = models.CharField(max_length=255,blank=True,null=True)
    intro= models.TextField(blank=True,null=True)
    personalSignature = models.CharField(max_length=255,blank=True,null=True)
    

    def __str__(self):
        return self.user_id.username
```

### Tutor

| 属性名  | 数据类型 | 备注         |
| ------- | -------- | ------------ |
| user_id | int      | 主码、主属性 |
| age     | int      | -            |
| gender  | int      | 0：男 1：女  |
| contact | varchar  | 主属性       |
| email   | email    | 主属性       |
| rating  | int      | -            |

```python
# 家教表 BCNF
class Tutor(models.Model):
    # 主码、主属性
    user_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='user_id_tutor')
    age = models.IntegerField(blank=True,null=True)
    gender = models.CharField(max_length=255,blank=True,null=True)
    # 主属性
    telephone = models.CharField(max_length=255,blank=True,null=True)
    # 主属性
    email = models.EmailField(max_length=255,blank=True,null=True)
    rate = models.FloatField(default=0)
    rateNum = models.IntegerField(default=0)
    address = models.CharField(max_length=255,blank=True,null=True)
    intro= models.TextField(blank=True,null=True)
    personalSignature = models.CharField(max_length=255,blank=True,null=True)
    degree = models.CharField(max_length=255,blank=True,null=True)

    def __str__(self):
        return self.user_id.username
```

Student与Tutor中存在部分共同的属性，但我们并未将其统一放至User中，这是因为我们认为User应当面向登录部分，而不应该包含过多的个人信息。在项目设计中，个人信息部分在**账户管理**页面进行补充，可以直接对应Student和Tutor表，不会带来冗余操作。

### 2.2 师生关系管理部分
这部分的表展示师生关系，其具体维护逻辑由于与事务逻辑强相关，我们将其放在下一节中详细讨论，此处仅给出表的定义。

### Link
| 属性名     | 数据类型 | 备注         |
| ---------- | -------- | ------------ |
| link_id  | int      | 主码、主属性 |
| student_id | int      | 外码         |
| tutor_id   | int      | 外码         |

```python
# 师生关系表 BCNF
class Link(models.Model):
    # 主码、主属性
    link_id = models.BigAutoField(primary_key=True)
    # 外码
    student_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='student_id_link')
    # 外码
    tutor_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='tutor_id_link')

    def __str__(self):
        return f"Link {self.link_id}"
```
师生关系Link与学生、家教这两个用户通过外码关联，保证了数据的一致性。

### 2.3 帖子管理部分
这部分内容有关帖子的管理。帖子是家教平台的核心内容，学生与家教的关系通过帖子建立，后续一系列逻辑也从帖子展开。由于学生和家教发布的帖子内容字段相同，我们将其统一放在Post表中，通过**user_id**区分发布者是学生还是家教。

### Post

| 属性名          | 数据类型 | 备注         |
| --------------- | -------- | ------------ |
| post_id         | int      | 主码、主属性 |
| user_id      | int      | 外码         |
| title           | varchar  | -            |
| post_date        | date     | -            |
| start_date       | date     | -            |
| end_date         | date     | -            |
| content         | test     | -            |
| is_completed    | boolean  | -            |
| is_approved    | boolean  | -            |

```python
# Post表 BCNF
class Post(models.Model):
    # 主码、主属性
    post_id = models.BigAutoField(primary_key=True)
    # 外码
    user_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='user_id_post')
    title = models.CharField(max_length=255,blank=True,null=True)
    post_date = models.DateTimeField(blank=True,null=True)
    start_date = models.DateField(blank=True,null=True)
    end_date = models.DateField(blank=True,null=True)
    content = models.TextField(blank=True,null=True)
    is_completed = models.BooleanField()
    is_approved = models.BooleanField(default=False)

    def __str__(self):
        return self.title
    
    class Meta:
        indexes = [
            models.Index(fields=['post_id']),
            models.Index(fields=['title']),
        ]
```

### PostSubject
这个属性的设置是由于每条帖子的subject是一个列表，为规避表中套表的嫌疑，将关系模式规范到3NF及以上，我们将subject单独拿出来，通过外码与Post关联。

| 属性名         | 数据类型 | 备注                           |
| -------------- | -------- | ------------------------------ |
| post_id | int      | 外码                           |
| subject        | varchar  | 与post_id一同组成主属性 |

```python
# Post表的科目表 BCNF
class PostSubject(models.Model):
    # 主码、主属性
    post_id = models.ForeignKey(Post, on_delete=models.CASCADE,related_name='post_id_subject')
    subject = models.CharField(max_length=255,blank=True,null=True)

    def __str__(self):
        return self.subject
```

### 2.4 其他事务部分
这部分内容有关其他事务的管理，主要包括通知、学习资料、评价、待办事项、管理员公告等功能。

### Notification

| 属性名                 | 数据类型 | 备注         |
| ---------------------- | -------- | ------------ |
| notification_id | int      | 主码、主属性 |
| user_id             | int      | 外码         |
| notification_date       | date     | -            |
| title       | varchar     | -            |
| description                | text     | -            |
| is_read                | boolean  | -            |

```python
# 通知表 BCNF   
class Notification(models.Model):
    # 主码、主属性
    notification_id = models.BigAutoField(primary_key=True)
    # 外码
    user_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='user_id_notice')
    notificationDate = models.DateTimeField(blank=True,null=True)
    title = models.CharField(max_length=255,blank=True,null=True)
    description = models.TextField(blank=True,null=True)
    is_read = models.BooleanField()

    def __str__(self):
        return self.title
    
    class Meta:
        ordering = ['-notificationDate']
        indexes = [
            models.Index(fields=['notification_date']),
        ]
```

### StudyMaterial

| 属性名      | 数据类型 | 备注         |
| ----------- | -------- | ------------ |
| material_id | int      | 主码、主属性 |
| tutor_id | int      | 外码         |
| student_id | int      | 外码         |
| file_name       | varchar     | -            |
| download_link       | varchar     | -            |
| upload_ate  | date     | -            |

```python
# 学习资料表 BCNF
class StudyMaterial(models.Model):
    # 主码、主属性
    material_id = models.BigAutoField(primary_key=True)
    # 外码
    tutor_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='tutor_id_material')
    # 外码
    student_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='student_id_material')
    file_name = models.CharField(max_length=255)
    download_link = models.CharField(max_length=255)
    upload_date = models.DateField()

    def __str__(self):
        return f"Material {self.material_id}"
    
    class Meta:
        ordering = ['-upload_date']
        indexes = [
            models.Index(fields=['upload_date']),
        ]
```

### Review

| 属性名     | 数据类型 | 备注         |
| ---------- | -------- | ------------ |
| review_id  | int      | 主码、主属性 |
| student_id | int      | 外码         |
| tutor_id   | int      | 外码         |
| rating     | int      | -            |
| content    | text     | -            |
| date    | date     | -            |

```python
# 评价表 BCNF
class Review(models.Model):
    # 主码、主属性
    review_id = models.BigAutoField(primary_key=True)
    # 外码
    student_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='student_id_review')
    # 外码
    tutor_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='tutor_id_review')
    rating = models.FloatField(blank=True,null=True)
    content = models.TextField(blank=True,null=True)
    date= models.DateField(blank=True,null=True)

    def __str__(self):
        return f"Review {self.review_id}"
    
    class Meta:
        ordering = ['-date']
        indexes = [
            models.Index(fields=['date']),
        ]
```

### Todo

| 属性名     | 数据类型 | 备注         |
| ---------- | -------- | ------------ |
| todo_id  | int      | 主码、主属性 |
| owner_id | int      | 外码         |
| accepter_id   | int      | 外码         |
| accepter_post_id   | int      | 外码         |
| is_completed     | int      | -            |

```python
# 待办事项表 BCNF
class Todo(models.Model):
    # 主码、主属性
    todo_id = models.BigAutoField(primary_key=True)
    # 外码
    owner_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='owner_id_todo')
    accepter_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='sender_id_todo')
    accept_post_id = models.ForeignKey(Post, on_delete=models.CASCADE,related_name='source_post_id_todo')
    is_completed = models.BooleanField()

    def __str__(self):
        return f"Todo {self.todo_id}"
```

### Announcement

| 属性名     | 数据类型 | 备注         |
| ---------- | -------- | ------------ |
| announcement_id  | int      | 主码、主属性 |
| announcement_date | date      | -         |
| title   | varchar      | -         |
| description   | text      | -         |

```python
class Announcement(models.Model):
    # 主码、主属性
    announcement_id = models.BigAutoField(primary_key=True)
    announcement_date = models.DateTimeField(blank=True,null=True)
    title = models.CharField(max_length=255,blank=True,null=True)
    description = models.TextField(blank=True,null=True)

    def __str__(self):
        return self.title
    
    class Meta:
        ordering = ['-announcement_date']
        indexes = [
            models.Index(fields=['announcement_date']),
        ]
```

### 3.7 存储过程
### 3.7.1 用户管理（注册/登录）
1. 用户注册

* **涉及的基本表**：`User`，`Student`，`Tutor`

* **过程描述**：检查用户是否被注册。如果未被注册，则将用户信息插入到User表中，再根据身份信息插入到Student或Tutor表中，并给用户发送一条注册成功的通知。值得注意的是，管理员账号只能由超级管理员手动添加，因此不会出现管理员注册的情况。
```python
@csrf_exempt
def register(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        username = body.get('name')
        password = body.get('password')
        role = body.get('role')
        try:
            # 检查用户是否已经存在
            user = User.objects.get(username=username)
            result={'data':{}}
            result['code'] = -1
            return JsonResponse(result)
        except User.DoesNotExist:
            # 创建用户
            user = User(username=username, 
                        password=password, 
                        identity=-1,
                        registration_date=datetime.now(pytz.timezone('Asia/Shanghai')))
            result={'data':{}}
            if role == "admin":
                raise Exception("管理员账号只能由超级管理员手动添加")
            elif role == "teacher":
                user.identity = 1
                user.save()
                tutor=Tutor(user_id=user)
                tutor.save()
                result['data']['roles']=[{'id': 'teacher'}]
            elif role == "student":
                user.identity = 2
                user.save()
                student=Student(user_id=user)
                student.save()
                result['data']['roles']=[{'id': 'student'}]
            else:
                raise Exception("未知身份")

            request.session['user_id'] = user.user_id
            sendNotice(user,"注册成功","欢迎加入家教综合服务平台！")

            result['code'] = 0
            result['data']['token']="Authorization:" + str(random.random())
            result['data']['id'] = str(user.user_id)
            return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

2. 用户登录
* **涉及的基本表**：`User`

* **过程描述**：检查用户是否存在，如果存在则返回用户的身份信息，否则返回错误信息。值得注意的是，后续有相关业务需要知道当前用户的身份，因此在登录成功后将用户的user_id存入session中。
```python
@csrf_exempt
def login(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        username = body.get('name') 
        password = body.get('password')
        result = {'data': {}}
        try:
            # 查询数据库中是否存在对应的用户
            user = User.objects.get(username=username, password=password)
            if user.identity == 0:
                result['data']['roles'] = [{'id': 'admin'}]
            elif user.identity == 1:
                result['data']['roles'] = [{'id': 'teacher'}]
            elif user.identity == 2:
                result['data']['roles'] = [{'id': 'student'}]
            else:
                raise Exception("未知身份")
            result['data']['id'] = str(user.user_id)

            request.session['user_id'] = user.user_id 

            # 登录成功
            result['code'] = 0
            result['data']['token'] = "Authorization:" + str(random.random())
            result['message'] = "登录成功"
        except User.DoesNotExist:
            # 用户不存在或密码错误
            result['code'] = -1
            result['message'] = "账户名或密码错误"
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

3. 重置密码
* **涉及的基本表**：`User`
* **过程描述**：检查用户是否存在，如果存在则将用户的密码重置为新密码，否则返回错误信息。
```python
def resetPassword(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        user_id=int(body.get('id'))
        user=User.objects.get(user_id=user_id)
        old_password=body.get('oldpassword')
        new_password=body.get('password')
        if user.password!=old_password:
            return JsonResponse({'code': -1, 'message': '密码错误'})
        user.password=new_password
        user.save()
        return JsonResponse({'code': 0})
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

### 3.7.2 帖子广场管理
1. 发帖

* **涉及的基本表**：`Post`，`PostSubject`

* **过程描述**：检查帖子的内容是否完整，如果不完整则返回错误信息。如果内容完整，则将帖子信息插入到Post表中，再将帖子的科目信息插入到PostSubject表中。
```python
@csrf_exempt
def sendPost(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        request_id=int(body.get('id'))
        title = body.get('data').get('title')
        startDate = body.get('data').get('startDate')
        endDate = body.get('data').get('endDate')
        subjects=body.get('data').get('subjects')
        location=body.get('data').get('location')
        fullLocation=body.get('data').get('fullLocation')
        telephoneNumber=body.get('data').get('telephoneNumber')
        email=body.get('data').get('emailAddress')
        content=body.get('data').get('content')
        is_complete = all([title, startDate, endDate, subjects, location, fullLocation, telephoneNumber, content])
        if not is_complete:
            return JsonResponse({'code': 0})
        
        try :
            user=User.objects.get(user_id=request_id)
        except User.DoesNotExist:
            return JsonResponse({'code': -1, 'message': '用户不存在'})
        
        if user.identity ==0:
            raise Exception("管理员不通过sendPost发帖")
        else:
            post=Post(
                user_id=user,
                title=title,
                postDate=datetime.now(pytz.timezone('Asia/Shanghai')),
                startDate=startDate,
                endDate=endDate,
                location=location,
                fullLocation=fullLocation,
                telephoneNumber=telephoneNumber,
                emailAddress=email,
                content=content,
                is_completed=True,
                is_approved=False,
            )
            post.save()

            postSubjects = [
                PostSubject(post_id=post, subject=subject)
                for subject in subjects
            ]
            PostSubject.objects.bulk_create(postSubjects)

            result={'data':{}}
            result['code'] = 0
            return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

2. 保存模板

* **涉及的基本表**：`Post`，`PostSubject`

* **过程描述**：将帖子内容保存为模板，如果用户已经有模板，则更新模板内容，否则新建一个模板。模板与帖子用is_completed字段区分。
```python
@csrf_exempt
def savePost(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        request_id=int(body.get('id'))
        title = body.get('data').get('title')
        startDate = body.get('data').get('startDate') or None
        endDate = body.get('data').get('endDate') or None
        subjects=body.get('data').get('subjects')
        location=body.get('data').get('location')
        fullLocation=body.get('data').get('fullLocation')
        telephoneNumber=body.get('data').get('telephoneNumber')
        email=body.get('data').get('emailAddress') or None
        content=body.get('data').get('content')

        try:
            user=User.objects.get(user_id=request_id)
        except User.DoesNotExist:
            return JsonResponse({'code': -1, 'message': '用户不存在'})
        
        if user.identity ==0:
            raise Exception("管理员无法保存帖子")
        else:
            try:
                post=Post.objects.get(user_id=user,is_completed=False)
                post.title=title
                post.startDate=startDate
                post.endDate=endDate
                post.location=location
                post.fullLocation=fullLocation
                post.telephoneNumber=telephoneNumber
                post.emailAddress=email
                post.content=content
                post.save()
                PostSubject.objects.filter(post_id=post).delete()
                postSubjects = [
                    PostSubject(post_id=post, subject=subject)
                    for subject in subjects
                ]
                PostSubject.objects.bulk_create(postSubjects)
                result={'data':{}}
                result['code'] = 0
                return JsonResponse(result)
            except Post.DoesNotExist:
                post=Post(
                    user_id=user,
                    title=title,
                    startDate=startDate,
                    endDate=endDate,
                    location=location,
                    fullLocation=fullLocation,
                    telephoneNumber=telephoneNumber,
                    emailAddress=email,
                    content=content,
                    is_completed=False,
                    is_approved=False,
                )
                post.save()
                postSubjects = [
                    PostSubject(post_id=post, subject=subject)
                    for subject in subjects
                ]
                PostSubject.objects.bulk_create(postSubjects)
                result={'data':{}}
                result['code'] = 0
                return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

3. 获取模板

* **涉及的基本表**：`Post`，`PostSubject`

* **过程描述**：获取用户的模板，如果用户没有模板，则返回空数据。  
```python
@csrf_exempt
def getSavedPost(request):
    if request.method == 'GET':
        try:
            user_id=request.GET.get('id')
            user=User.objects.get(user_id=int(user_id))
            if user.identity==0:
                raise Exception("管理员无法获取帖子")
            else:
                try:
                    post=Post.objects.get(user_id=user,is_completed=False)
                    result={'data':{}}
                    result['code'] = 0
                    result['data']['title']=post.title
                    result['data']['startDate']=post.startDate
                    result['data']['endDate']=post.endDate
                    location=post.location.strip('"')
                    location=json.loads(location.replace("'",'"'))
                    result['data']['location']=location
                    result['data']['fullLocation']=post.fullLocation
                    result['data']['telephoneNumber']=post.telephoneNumber
                    result['data']['emailAddress']=post.emailAddress
                    result['data']['content']=post.content
                    subjects=PostSubject.objects.filter(post_id=post)
                    result['data']['subjects']=[subject.subject for subject in subjects]
                except:
                    result={'data':{}}
                    result['code'] = 0
                return JsonResponse(result)
        except User.DoesNotExist:
            result={'data':{}}
            result['code'] = 0
            return JsonResponse(result)     
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

4. 在帖子广场上获取帖子

* **涉及的基本表**：`Post`，`PostSubject`

* **过程描述**：获取帖子广场上的帖子，并根据搜索关键词以及用户身份进行筛选。具体来说，首先学生只会看到家教发的帖子，家教会看到学生发的帖子，管理员会看到所有尚未审核的帖子。然后根据搜索关键词进行筛选，匹配字段包含科目、用户名、标题、内容、地址。如果搜索关键词为空，则返回所有符合条件的帖子。采用模糊匹配。
```python
@csrf_exempt
def getPosts(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        request_page=int(request.GET.get('page'))
        request_query=request.GET.get('query')
        start=(request_page-1)*10
        end=request_page*10
        returnSubjects=[]
        user=User.objects.get(user_id=request_id)
        try:
            if user.identity==1:
                filter_id=2
            else:
                filter_id=1
            
            if request_query=="":
                if user.identity!=0:
                    posts=Post.objects.filter(is_completed=True,user_id__identity=filter_id,is_approved=True)
                else:
                    posts=Post.objects.filter(is_completed=True,is_approved=False)
            else:
                all_posts = Post.objects.all()
                matching_posts = []
                for post in all_posts:
                    subjects=PostSubject.objects.filter(post_id=post).values_list('subject', flat=True)
                    subjects_str = ' '.join(subjects)
                    username_str = post.user_id.username
                    title_str = post.title
                    content_str = post.content
                    location_str = post.location.strip('"')
                    location_list = json.loads(location_str.replace("'", '"'))
                    location_str = ' '.join(location_list) if isinstance(location_list, list) else location_str
                    long_str = f"{subjects_str} {username_str} {title_str} {content_str} {location_str}".lower()
                    
                    request_query = request_query.lower()
                    if request_query in long_str:
                        matching_posts.append(post)
                if user.identity != 0:
                    posts = [post for post in matching_posts if post.is_completed and post.user_id.identity == filter_id and post.is_approved]
                else:
                    posts = [post for post in matching_posts if post.is_completed and not post.is_approved]
            
            return_posts=[]
            for post in posts:
                user=post.user_id
                now = datetime.now(pytz.timezone('Asia/Shanghai'))
                post_date = post.postDate.astimezone(pytz.timezone('Asia/Shanghai'))
                time_diff = now - post_date
                if time_diff < timedelta(hours=24):
                    date_display = f"{time_diff.seconds // 3600}小时前"
                elif time_diff < timedelta(days=3):
                    date_display = f"{time_diff.days}天前"
                else:
                    date_display = post_date.strftime("%Y-%m-%d")
                return_subject_lines=PostSubject.objects.filter(post_id=post)
                returnSubjects=[]
                returnSubjects = [subject.subject for subject in return_subject_lines]
                location=post.location.strip('"')
                location=json.loads(location.replace("'",'"'))
                location=location[0]
                return_posts.append({
                    'id':str(post.post_id),
                    'title':post.title,
                    'tags':returnSubjects,
                    'content':post.content,
                    'author':user.username,
                    'authorId':user.user_id,
                    'date':date_display,
                    'location':location,
                })
            result={'posts':return_posts[start:end],'total':len(posts)}
            return JsonResponse(result)
        except User.DoesNotExist:
            raise Exception("用户不存在")
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```


5. 获取用户所发的帖子
* **涉及的基本表**：`Post`，`PostSubject`
* **过程描述**：根据帖子id直接获取帖子内容，如果帖子不存在则返回错误信息。
```python
@csrf_exempt
def getPost(request):
    if request.method == 'GET':
        post_id=int(request.GET.get('id'))
        try:
            post=Post.objects.get(post_id=post_id)
            result={'data':{}}
            result['code'] = 0
            result['data']['title']=post.title
            result['data']['author']=post.user_id.username
            location=post.location.strip('"')
            location=json.loads(location.replace("'",'"'))
            result['data']['location']=location
            result['data']['fullLocation']=post.fullLocation
            result['data']['telephoneNumber']=post.telephoneNumber
            result['data']['emailAddress']=post.emailAddress
            result['data']['startDate']=post.startDate
            result['data']['endDate']=post.endDate
            subject_lines=PostSubject.objects.filter(post_id=post)
            subjects=[]
            subjects = [subject.subject for subject in subject_lines]
            result['data']['subjects']=subjects
            result['data']['content']=post.content
            return JsonResponse(result)
            
        except Post.DoesNotExist:
            return JsonResponse({'code': -1, 'message': '帖子不存在'})
```

### 3.7.3 师生个人信息管理
1. 更新学生信息
* **涉及的基本表**：`Student`
* **过程描述**：更新学生的个人信息。
```python
@csrf_exempt
def updateStudentInfo(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        request_id=int(body.get('id'))
        grade = body.get('data').get('grade')
        gender = body.get('data').get('gender')
        age=body.get('data').get('age')
        email=body.get('data').get('email')
        telephone=body.get('data').get('telephone')
        address=body.get('data').get('address')
        intro=body.get('data').get('intro')
        personalSignature=body.get('data').get('personalSignature')

        user=User.objects.get(user_id=request_id)
        student=Student.objects.get(user_id=user)
        student.grade=grade
        student.gender=gender
        student.age=age
        student.email=email
        student.telephone=telephone
        student.address=address
        student.intro=intro
        student.personalSignature=personalSignature
        student.save()

        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

2. 获取学生信息
* **涉及的基本表**：`Student`
* **过程描述**：获取学生的个人信息。
```python
@csrf_exempt
def getStudentInfo(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        result={'data':{}}
        result['code'] = 0
        user=User.objects.get(user_id=request_id)
        student=Student.objects.get(user_id=user)
        result['data']['name']=user.username
        result['data']['email']=student.email
        result['data']['telephone']=student.telephone
        result['data']['address']=student.address
        result['data']['personalSignature']=student.personalSignature
        result['data']['intro']=student.intro
        result['data']['age']=student.age
        result['data']['gender']=student.gender
        result['data']['grade']=student.grade
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

3. 更新家教信息
* **涉及的基本表**：`Tutor`
* **过程描述**：更新家教的个人信息。
```python
@csrf_exempt
@csrf_exempt
def updateTeacherInfo(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        request_id=int(body.get('id'))
        degree=body.get('data').get('degree')
        gender=body.get('data').get('gender')
        age=body.get('data').get('age')
        email=body.get('data').get('email')
        telephone=body.get('data').get('telephone')
        address=body.get('data').get('address')
        intro=body.get('data').get('intro')
        personalSignature=body.get('data').get('personalSignature')

        user=User.objects.get(user_id=request_id)
        tutor=Tutor.objects.get(user_id=user)
        tutor.degree=degree
        tutor.gender=gender
        tutor.age=age
        tutor.email=email
        tutor.telephone=telephone
        tutor.address=address
        tutor.intro=intro
        tutor.personalSignature=personalSignature
        tutor.save()

        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

4. 获取家教信息
* **涉及的基本表**：`Tutor`
* **过程描述**：获取家教的个人信息。注意在评论区需要获取评论学生的头像，如果学生没有头像则使用默认头像。
```python
@csrf_exempt
def getTeacherInfo(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))

        result={'data':{}}
        result['code'] = 0
        user=User.objects.get(user_id=request_id)
        tutor=Tutor.objects.get(user_id=user)
        result['data']['name']=user.username
        result['data']['email']=tutor.email
        result['data']['telephone']=tutor.telephone
        result['data']['address']=tutor.address
        result['data']['personalSignature']=tutor.personalSignature
        result['data']['intro']=tutor.intro
        result['data']['gender']=tutor.gender
        result['data']['age']=tutor.age
        result['data']['degree']=tutor.degree
        result['data']['rate']=round(tutor.rate,1)
        result['data']['rateNum']=tutor.rateNum
        comments=Review.objects.filter(tutor_id=user)
        return_comments=[]
        for comment in comments:
            return_comments.append({
                'id':str(comment.review_id),
                'authorName':comment.student_id.username,
                'rating':comment.rating,
                'content':comment.content,
                'date':comment.date,
                'avatar':comment.student_id.avatar if comment.student_id.avatar else 'http://120.46.1.4:9000/zxb/png/Akkarin.png',
            })
        result['data']['comments']=return_comments
        print(result)
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

5. 更新头像
* **涉及的基本表**：`User`
* **过程描述**：更新用户的头像。注意为了避免图片重名，我们使用uuid生成唯一文件名，将文件上传至图床后，将访问链接保存至数据库中。
```python
def uploadAvatar(request):
    if request.method == 'POST':
        id_request=json.loads(request.POST.get('data'))
        # 使用 request.POST 和 request.FILES 解析 FormData 对象
        user_id = int(id_request.get('id'))
        file = request.FILES['file']  # 获取上传的文件
        file_name = file.name
        file_type = file_name.split('.')[-1]

        unique_file_name = f"{uuid.uuid4()}.{file_type}"

        try:
            user = User.objects.get(user_id=user_id)
        except User.DoesNotExist:
            return JsonResponse({'code': 1, 'message': '用户不存在'})

        # 使用 MinioClient 上传文件并获取下载链接
        minio_client = MinioClient()
        file_data = file.read()
        try:
            minio_client.upload_file(file_data, unique_file_name, file_type)
            download_link = get_download_url(unique_file_name, file_type)
        except ValueError as e:
            return JsonResponse({'code': 1, 'message': str(e)})

        # 更新用户头像链接
        user.avatar = download_link
        user.save()

        result = {'code': 0, 'message': ''}
        return JsonResponse(result)
    else:
        return JsonResponse({'code': 1, 'message': '仅支持POST请求'})
```

6. 获取头像
* **涉及的基本表**：`User`
* **过程描述**：获取用户的头像。如果用户没有头像，则使用默认头像。
```python
def getAvatar(request):
    if request.method == 'GET':
        user_id = int(request.GET.get('id'))
        try:
            user = User.objects.get(user_id=user_id)
        except User.DoesNotExist:
            return JsonResponse({'code': 1, 'message': '用户不存在'})

        if user.avatar:
            avatar_url = user.avatar
        else:
            avatar_url = 'http://120.46.1.4:9000/zxb/png/Akkarin.png'
        print(avatar_url)
        result = {'code': 0, 'avatar': avatar_url}
        print(result)
        return JsonResponse(result)
    else:
        return JsonResponse({'code': 1, 'message': '仅支持GET请求'})
```


### 3.7.4 个人工作管理
1. 获取本人发布的所有帖子
* **涉及的基本表**：`Post`，`PostSubject`
* **过程描述**：获取用户发布的所有帖子。注意，有别于帖子广场，未经审核的帖子也会在这里显示。
```python
def getUserPosts(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        user=User.objects.get(user_id=request_id)
        posts=Post.objects.filter(user_id=user,is_completed=True)

        return_posts=[]
        result={}
        result['code'] = 0
        for post in posts:
            return_posts.append({
                'id':str(post.post_id),
                'title':post.title,
                'content':post.content,
            })
        result['posts']=return_posts
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

2. 删除自己发布的帖子
* **涉及的基本表**：`Post`，`PostSubject`
* **过程描述**：用户可以自行删除自己发布的帖子。
```python
def deletePost(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        post_id=int(body.get('postId'))
        post=Post.objects.get(post_id=post_id)
        post.delete()
        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

3. 家教获取自己的所有学生
* **涉及的基本表**：`Link`
* **过程描述**：家教可以获取自己的所有学生。
```python
def getStudents(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        students=Link.objects.filter(tutor_id=request_id)
        return_students=[]
        result={}
        result['code'] = 0
        for student in students:
            return_students.append({
                'id':str(student.student_id.user_id),
                'name':student.student_id.username,
            })
        result['students']=return_students
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

4. 学生获取自己的家教
* **涉及的基本表**：`Link`
* **过程描述**：学生可以获取自己的家教。
```python
def getTutors(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        tutors=Link.objects.filter(student_id=request_id)
        return_tutors=[]
        result={}
        result['code'] = 0
        for tutor in tutors:
            return_tutors.append({
                'id':str(tutor.tutor_id.user_id),
                'name':tutor.tutor_id.username,
            })
        result['tutors']=return_tutors
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

5. 发送通知
* **涉及的基本表**：`Notification`
* **过程描述**：用户在执行相关工作后，会发送信息给涉及到的其他用户。这是一个工具方法，前端并不会直接调用这一api。
```python
def sendNotice(user,title,description):
    notification=Notification(
        user_id=user,
        notificationDate=datetime.now(pytz.timezone('Asia/Shanghai')),
        title=title,
        description=description,
        is_read=False,
        )
    notification.save()
```

6. 获取通知
* **涉及的基本表**：`Notification`
* **过程描述**：用户可以获取自己的通知。
```python
def getNotices(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        user=User.objects.get(user_id=request_id)
        notifications=Notification.objects.filter(user_id=user)

        return_notifications=[]
        result={'data':{}}
        result['code'] = 0
        for notification in notifications:
            return_notifications.append({
                'title':notification.title,
                'description':notification.description,
            })
        result['data']['notices']=return_notifications
        new_len=len(Notification.objects.filter(user_id=user,is_read=False))
        Notification.objects.filter(user_id=user).update(is_read=True)
        result['data']['newNum']=new_len
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

7. 完成待办事项以建立师生关系
* **涉及的基本表**：`Todo`，`Link`
* **过程描述**：家教和学生通过完成待办事项建立关系。
```python
def link(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        tutor_id=int(body.get('teacherId'))
        student_id=int(body.get('studentId'))
        tutor=User.objects.get(user_id=tutor_id)
        student=User.objects.get(user_id=student_id)

        link=Link(tutor_id=tutor,student_id=student)
        link.save()

        user_id=request.session['user_id']
        if user_id==tutor_id:
            sendNotice(student,"招聘成功",f"您正式成为{tutor.username}的学生")
            todos=Todo.objects.filter(owner_id=tutor,accepter_id=student)
            for todo in todos:
                todo.delete()
        else:
            sendNotice(tutor,"应聘成功",f"您正式成为{student.username}的家教")
            todos=Todo.objects.filter(owner_id=student,accepter_id=tutor)
            for todo in todos:
                todo.delete()

        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

8. 拒绝待办事项
* **涉及的基本表**：`Todo`
* **过程描述**：家教和学生通过拒绝待办事项拒绝建立关系。
```python
def refuseLink(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        tutor_id=int(body.get('teacherId'))
        student_id=int(body.get('studentId'))
        tutor=User.objects.get(user_id=tutor_id)
        student=User.objects.get(user_id=student_id)

        user_id=request.session['user_id']
        if user_id==tutor_id:
            sendNotice(student,"招聘失败",f"很抱歉，{tutor.username}未同意您的招聘")
            todos=Todo.objects.filter(owner_id=tutor,accepter_id=student)
            for todo in todos:
                todo.delete()
        else:
            sendNotice(tutor,"应聘失败",f"很抱歉，{student.username}未同意您的应聘")
            todos=Todo.objects.filter(owner_id=student,accepter_id=tutor)
            for todo in todos:
                todo.delete()

        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

9. 取消师生关系
* **涉及的基本表**：`Link`
* **过程描述**：家教和学生通过取消师生关系解除关系。
```python
def unlink(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        print(body)
        tutor_id=int(body.get('id'))
        student_id=int(body.get('studentId'))
        tutor=User.objects.get(user_id=tutor_id)
        student=User.objects.get(user_id=student_id)

        link=Link.objects.get(tutor_id=tutor,student_id=student)
        link.delete()

        user_id=request.session['user_id']
        if user_id==tutor_id:
            sendNotice(student,"解除招聘",f"您已经不再是{tutor.username}的学生")
        else:
            sendNotice(tutor,"解除应聘",f"您已经不再是{student.username}的家教")

        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

10.  学生给家教评价
* **涉及的基本表**：`Review`
* **过程描述**：学生给家教评价。
```python
def submitComment(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        student_id=int(body.get('studentId'))
        tutor_id=int(body.get('teacherId'))
        rating=int(body.get('rate'))
        comment=body.get('comment')
        user=User.objects.get(user_id=student_id)
        tutor=User.objects.get(user_id=tutor_id)
        teacher=Tutor.objects.get(user_id=tutor)
        if teacher.rateNum!=0:
            rate_sum=teacher.rate*teacher.rateNum
        else:
            rate_sum=0
        old_review=Review.objects.get(student_id=user,tutor_id=tutor)
        if old_review:
            teacher.rateNum-=1
            rate_sum-=old_review.rating  
            old_review.delete()
        review=Review(
            student_id=user,
            tutor_id=tutor,
            rating=rating,
            content=comment,
            date=datetime.now(pytz.timezone('Asia/Shanghai')),
        )
        review.save()

        sendNotice(tutor,"收到新评价",f"您收到了来自{user.username}的新评价")
        teacher.rateNum+=1
        rate_sum+=rating
        teacher.rate=rate_sum/teacher.rateNum
        teacher.save()
        
        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'}) 
```

11.  家教给学生上传学习资料
* **涉及的基本表**：`StudyMaterial`
* **过程描述**：家教给学生上传学习资料。为避免重名文件发生覆盖，这里在上传图床前使用uuid生成唯一文件名，然后将文件名和下载链接存入数据库。
```python
def submitLearningMaterial(request):
    if request.method == 'POST':
        body = json.loads(request.POST.get('data'))
        tutor_id = int(body.get('id'))
        student_id = int(body.get('studentId'))
        file = request.FILES['file']  # 获取上传的文件
        file_name = file.name
        file_type = file_name.split('.')[-1]
        user=User.objects.get(user_id=student_id)
        tutor=User.objects.get(user_id=tutor_id)

        unique_file_name = f"{uuid.uuid4()}.{file_type}"

        minio = MinioClient()
        file_data = file.read()
        minio.upload_file(file_data, unique_file_name, file_type)
        download_link = get_download_url(unique_file_name, file_type)

        material=StudyMaterial(
            tutor_id=tutor,
            student_id=user,
            file_name=file_name,
            download_link=download_link,
            upload_date=datetime.now(pytz.timezone('Asia/Shanghai')),
        )
        material.save()
        sendNotice(user,"收到新学习资料",f"您收到了来自{tutor.username}的新学习资料")
        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

12.  学生获取学习资料
* **涉及的基本表**：`StudyMaterial`
* **过程描述**：学生获取家教上传的学习资料。
```python
def getLearningMaterials(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        user=User.objects.get(user_id=request_id)
        materials=StudyMaterial.objects.filter(student_id=user)

        return_materials=[]
        result={}
        result['code'] = 0
        for material in materials:
            return_materials.append({
                'id':str(material.material_id),
                'filename':material.file_name,
                'publisher':material.tutor_id.username,
                'downloadLink':material.download_link,
                'date':material.upload_date,
            })
        result['materials']=return_materials
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

13.  发送待办事项
* **涉及的基本表**：`Todo`
* **过程描述**：用户在执行相关工作后，会发送待办事项给涉及到的其他用户。这是一个工具方法，前端并不会直接调用这一api。
```python
def sendTodo(user,post,accepter):
    todo=Todo(
        owner_id=user,
        accepter_id=accepter,
        accept_post_id=post,
        is_completed=False,
    )
    todo.save()
```

14.  获取待办事项
* **涉及的基本表**：`Todo`
* **过程描述**：用户可以获取自己的待办事项。
```python
def getTodos(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        user=User.objects.get(user_id=request_id)
        todos=Todo.objects.filter(owner_id=user)

        return_todos=[]
        result={}
        result['code'] = 0
        for todo in todos:
            return_todos.append({
                'id':str(todo.todo_id),
                'postId':str(todo.accept_post_id.post_id),
                'postTitle':todo.accept_post_id.title,
                'accepterName':todo.accepter_id.username,
                'accepterId':str(todo.accepter_id.user_id),
            })
        result['todos']=return_todos
        print(result)
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

15. 获取站点公告
* **涉及的基本表**：`Announcement`
* **过程描述**：用户可以获取站点公告。
```python
def getAnnouncements(request):
    if request.method == 'GET':
        try:
            return_announcements=[]
            for announcement in Announcement.objects.all():
                now = datetime.now(pytz.timezone('Asia/Shanghai'))
                announcement_date = announcement.announcementDate.astimezone(pytz.timezone('Asia/Shanghai'))
                time_diff = now - announcement_date
                if time_diff < timedelta(hours=24):
                    date_display = f"{time_diff.seconds // 3600}小时前"
                elif time_diff < timedelta(days=3):
                    date_display = f"{time_diff.days}天前"
                else:
                    date_display = announcement_date.strftime("%Y-%m-%d")
                return_announcements.append({
                    'title':announcement.title,
                    'content':announcement.description,
                    'date':date_display,
                })
            result={'data':{}}
            result['code'] = 0
            result['data']['announcements']=return_announcements
            return JsonResponse(result)
        except User.DoesNotExist:
            raise Exception("用户不存在")
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```


### 3.7.5 管理员事务管理
1. 获取用户身份
* **涉及的基本表**：`User`
* **过程描述**：管理员可以获取用户的身份。
```python
def getUserRole(request):
    if request.method == 'GET':
        post_id=int(request.GET.get('id'))
        post=Post.objects.get(post_id=post_id)
        user=post.user_id
        result={'data':{}}
        result['code'] = 0
        if user.identity==0:
            raise Exception("管理员不发帖子")
        elif user.identity==1:
            result['data']['userRole']="家教"
        else:
            result['data']['userRole']="学生"
        print(result)
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

2. 审核通过帖子
* **涉及的基本表**：`Post`
* **过程描述**：管理员可以审核通过帖子。
```python
def approvePost(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        print(body)
        post_id=int(body.get('postId'))
        post=Post.objects.get(post_id=post_id)
        post.is_approved=True
        post.save()
        sendNotice(post.user_id,"帖子通过审核",f"您的帖子《{post.title}》已通过审核")
        result={}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

3. 审核拒绝帖子
* **涉及的基本表**：`Post`
* **过程描述**：管理员可以审核拒绝帖子。
```python
def rejectPost(request):
    if request.method == 'POST':
        body = json.loads(request.body)5.
        post_id=int(body.get('postId'))
        post=Post.objects.get(post_id=post_id)
        post.delete()
        sendNotice(post.user_id,"帖子未通过审核",f"您的帖子《{post.title}》未通过审核")
        result={}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

4. 获取所有家教
* **涉及的基本表**：`Tutor`
* **过程描述**：管理员可以获取所有家教。
```python
def getAllTeachers(request):
    if request.method == 'GET':
        teachers=User.objects.filter(identity=1)
        return_teachers=[]
        result={}
        result['code'] = 0
        for teacher in teachers:
            return_teachers.append({
                'id':str(teacher.user_id),
                'name':teacher.username,
            })
        result['teachers']=return_teachers
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

5. 获取所有学生
* **涉及的基本表**：`Student`
* **过程描述**：管理员可以获取所有学生。
```python
def getAllStudents(request):
    if request.method == 'GET':
        students=User.objects.filter(identity=2)
        return_students=[]
        result={}
        result['code'] = 0
        for student in students:
            return_students.append({
                'id':str(student.user_id),
                'name':student.username,
            })
        result['students']=return_students
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
``` 

6. 发表站点公告
* **涉及的基本表**：`Announcement`
* **过程描述**：管理员可以发表站点公告。
```python
def makeAnnouncement(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        title=body.get('title')
        content=body.get('content')
        announcement=Announcement(
              title=title,
              description=content,
              announcementDate=datetime.now(pytz.timezone('Asia/Shanghai')),
        )
        announcement.save()
        result={}
        result['code']=0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

7. 删除用户
* **涉及的基本表**：`User`
* **过程描述**：管理员可以删除用户。
```python
def deleteUser(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        user_id=int(body.get('id'))
        user=User.objects.get(user_id=user_id)
        user.delete()
        result={}
        result['code']=0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```


