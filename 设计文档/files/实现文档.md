## 1.1 体系结构

### 1.1.1 总体结构

本项目采用前后端分离的体系结构，前后端通过api来交换数据。前端通过api向后端请求数据，后端控制器负责根据前端的不同请求， 来对数据库进行存取操作， 进而将数据返回给前端。 前端得到数据后将数据渲染在网页上， 进而实现前后端的交互，如下图所示。

![屏幕截图 2024-12-20 105513](C:\Users\LX\Pictures\Screenshots\屏幕截图 2024-12-20 105513.png)

### 1.1.2 前端结构

**assets**：

用于存储静态资源，例如网站logo、图片、字体。

**components**:

包含多次重复使用的或功能较为独立的Vue组件，例如固定按钮、侧边栏、导航栏、密码修改表单等。

**router**：

存放控制应用路由的JS文件，具体路由配置可参考config.js。

**page**：

存放应用界面的Vue文件，每个子文件夹对应一个具体功能页面。

**services**：

存放api相关JS文件，用于与后端交互。

**mock**：

存放模拟数据和服务器响应，扮演一个临时的、轻量级的服务端角色，帮助我们在没有真实后端API或是在后端API尚未完成的情况下进行前端开发和测试。

### 1.1.3 后端结构

后端使用Django框架实现。文件结构如下：

* **myapp**

  * **migrations**

    这个文件夹中是Django生成的数据库迁移代码，用于修改模型类后将修改执行到数据库。

  * **models.py**

    该文件定义了模型类，对应数据库的表，具体内容间本文档第二部分。

  * **url.py**

    该文件定义路由，通过设置文件中的路由，可以将不同的请求发送到不同的视图函数中进行处理。

  * **views.py**

    该文件定义视图函数，通过与数据模型进行交互，实现项目的相关功能。

* **backend**

  后端基本文件，用于进行一些配置，主要有Django框架生成。

* **manage.py**

  脚本，用于后端的部署、数据库的迁移等。

## 1.2 功能结构

功能架构示意图如下：

![数据库绘图.drawio](D:\数据库绘图.drawio.png)

### 1.3.1 登录注册

* 登录：可以通过输入用户名和对应的正确密码，登录进入功能页面，否则无法进入功能页面。
* 注册：可通过输入用户名、密码，选择家教或老师的身份，当后台查验无误的时候，即可注册账户。
* 登出：用户登录后可以选择登出，登出后用户失去访问功能页面的权限。
* 修改密码：在登陆后可以选择修改密码，用户的密码会被设置成新的密码。

### 1.3.2 个人主页

* 查看个人主页：学生和家教可以查看自己的主页，家教主页会额外显示自己的学生对自己的评价。
* 编辑个人主页：用户可以随时编辑自己的主页，修改例如年龄、邮箱、联系方式等个人信息。

### 1.3.3 管理端

* 发布公告：管理员可以对所有用户发布公告，用户可以在公告页面查看。
* 帖子审核：学生和家教发布的帖子需要被管理员审核通过后才会在广场上显示，管理员可驳回待通过的帖子。
* 用户管理：管理员可以删除任意用户，将其加入黑名单。

### 1.3.4 广场

* 帖子检索：广场提供搜索功能，并支持基本的模糊搜索。
* 帖子详情：在招聘帖中，家教可以选择接受招聘；在求聘帖中，学生可以选择接收求聘。

### 1.3.5 发帖

学生（家教）用户可以通过在侧边栏选择我要招聘（我要求聘）进入发帖页面，在这个页面用户可以填写自己的基本信息以及需求。

* 保存：用户可以对已填写内容进行保存。
* 提交：用户可以提交帖子，提交后的帖子经管理员审核通过后便会出现在广场界面。

### 1.3.6 消息通知

当发生”帖子通过审核“”有新的公告“”家教发布学习资料“”请求建立师生关系“”成功建立师生关系“等多种情况时都会产生通知信息，以便用户及时获取重要信息。

### 1.3.7 学生学习

* 学生可以查看自己发布过的帖子，可以选择删除之前发布的帖子。
* 学生可以查看自己的家教信息，选择与其解除师生关系，对家教发表评价。
* 学生可以浏览自己的待办事项，并选择接受或者拒绝。
* 学生可以查看家教给自己上传的学习资料。

### 1.3.8 家教工作

* 家教可以查看自己发布过的帖子，可以选择删除之前发布的帖子。
* 家教可以查看自己的学生信息，选择与其解除师生关系，给学生上传学习资料。
* 家教可以浏览自己的待办事项，并选择接受或者拒绝。
* 家教可以查看自己已上传的学习资料。

## 二、数据库基本表的定义

数据库共包含10个实体，11张表，采用Django提供的数据库访问接口实现数据库表的定义以及访问

### 2.1 用户管理部分

这部分内容有关用户的管理，主要包括用户的登录、注册、修改密码等功能。该系统中有三类用户，分别为学生、家教和管理员，其中管理员无法注册，只能由超级管理员（网站管理者）手动添加。考虑到老师和学生具有某些共同的性质（例如账号和密码），但是又有一些不同的属性（例如学生有成绩，家教有学生评分等），因此我们将Student和Tutor抽象为User统一管理，通过identity字段区分学生和家教，并通过**user_id**将User与其他表关联。

```python
# 用户表 BCNF
class User(models.Model):
    # 主码、主属性
    user_id = models.BigAutoField(primary_key=True)
    # 主属性
    username = models.CharField(max_length=255)
    password = models.CharField(max_length=255)
    identity = models.IntegerField()  # 0: 管理员,1: 家教, 2: 学生
    registration_date = models.DateField()

    def __str__(self):
        return self.username
    
    class Meta:
        ordering = ['-registration_date']
```

这种关系的设计可以在不需要继承的前提下使得学生和家教的共同属性可以在User表中维护，而不需要在Student和Tutor中重复定义。同时，这种设计也使得我们可以方便地通过user_id找到对应的学生或家教。

### Student

| 属性名  | 数据类型 | 备注         |
| ------- | -------- | ------------ |
| user_id | int      | 主码、主属性 |
| age     | int      | -            |
| gender  | int      | 0：男 1：女  |
| contact | varchar  | 主属性       |
| email   | email    | 主属性       |
| grade   | int      | -            |

```python
# 学生表 BCNF
class Student(models.Model):
    # 主码、主属性
    user_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='user_id_student')
    age = models.IntegerField(blank=True,null=True)
    gender = models.CharField(max_length=255,blank=True,null=True)
    # 主属性
    telephone = models.CharField(max_length=255,null=True,blank=True)
    # 主属性
    email = models.EmailField(max_length=255,blank=True,null=True)
    grade = models.CharField(max_length=255,blank=True,null=True)
    address = models.CharField(max_length=255,blank=True,null=True)
    intro= models.TextField(blank=True,null=True)
    personalSignature = models.CharField(max_length=255,blank=True,null=True)
    

    def __str__(self):
        return self.user_id.username
```

### Tutor

| 属性名  | 数据类型 | 备注         |
| ------- | -------- | ------------ |
| user_id | int      | 主码、主属性 |
| age     | int      | -            |
| gender  | int      | 0：男 1：女  |
| contact | varchar  | 主属性       |
| email   | email    | 主属性       |
| rating  | int      | -            |

```python
# 家教表 BCNF
class Tutor(models.Model):
    # 主码、主属性
    user_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='user_id_tutor')
    age = models.IntegerField(blank=True,null=True)
    gender = models.CharField(max_length=255,blank=True,null=True)
    # 主属性
    telephone = models.CharField(max_length=255,blank=True,null=True)
    # 主属性
    email = models.EmailField(max_length=255,blank=True,null=True)
    rate = models.FloatField(default=0)
    rateNum = models.IntegerField(default=0)
    address = models.CharField(max_length=255,blank=True,null=True)
    intro= models.TextField(blank=True,null=True)
    personalSignature = models.CharField(max_length=255,blank=True,null=True)
    degree = models.CharField(max_length=255,blank=True,null=True)

    def __str__(self):
        return self.user_id.username
```

Student与Tutor中存在部分共同的属性，但我们并未将其统一放至User中，这是因为我们认为User应当面向登录部分，而不应该包含过多的个人信息。在项目设计中，个人信息部分在**账户管理**页面进行补充，可以直接对应Student和Tutor表，不会带来冗余操作。

### 2.2 师生关系管理部分
这部分的表展示师生关系，其具体维护逻辑由于与事务逻辑强相关，我们将其放在下一节中详细讨论，此处仅给出表的定义。

### Link
| 属性名     | 数据类型 | 备注         |
| ---------- | -------- | ------------ |
| link_id  | int      | 主码、主属性 |
| student_id | int      | 外码         |
| tutor_id   | int      | 外码         |

```python
# 师生关系表 BCNF
class Link(models.Model):
    # 主码、主属性
    link_id = models.BigAutoField(primary_key=True)
    # 外码
    student_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='student_id_link')
    # 外码
    tutor_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='tutor_id_link')

    def __str__(self):
        return f"Link {self.link_id}"
```
师生关系Link与学生、家教这两个用户通过外码关联，保证了数据的一致性。

### 2.3 帖子管理部分
这部分内容有关帖子的管理。帖子是家教平台的核心内容，学生与家教的关系通过帖子建立，后续一系列逻辑也从帖子展开。由于学生和家教发布的帖子内容字段相同，我们将其统一放在Post表中，通过**user_id**区分发布者是学生还是家教。

### Post

| 属性名          | 数据类型 | 备注         |
| --------------- | -------- | ------------ |
| post_id         | int      | 主码、主属性 |
| user_id      | int      | 外码         |
| title           | varchar  | -            |
| post_date        | date     | -            |
| start_date       | date     | -            |
| end_date         | date     | -            |
| content         | test     | -            |
| is_completed    | boolean  | -            |
| is_approved    | boolean  | -            |

```python
# Post表 BCNF
class Post(models.Model):
    # 主码、主属性
    post_id = models.BigAutoField(primary_key=True)
    # 外码
    user_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='user_id_post')
    title = models.CharField(max_length=255,blank=True,null=True)
    post_date = models.DateTimeField(blank=True,null=True)
    start_date = models.DateField(blank=True,null=True)
    end_date = models.DateField(blank=True,null=True)
    content = models.TextField(blank=True,null=True)
    is_completed = models.BooleanField()
    is_approved = models.BooleanField(default=False)

    def __str__(self):
        return self.title
    
    class Meta:
        indexes = [
            models.Index(fields=['post_id']),
            models.Index(fields=['title']),
        ]
```

### PostSubject
这个属性的设置是由于每条帖子的subject是一个列表，为规避表中套表的嫌疑，将关系模式规范到3NF及以上，我们将subject单独拿出来，通过外码与Post关联。

| 属性名         | 数据类型 | 备注                           |
| -------------- | -------- | ------------------------------ |
| post_id | int      | 外码                           |
| subject        | varchar  | 与post_id一同组成主属性 |

```python
# Post表的科目表 BCNF
class PostSubject(models.Model):
    # 主码、主属性
    post_id = models.ForeignKey(Post, on_delete=models.CASCADE,related_name='post_id_subject')
    subject = models.CharField(max_length=255,blank=True,null=True)

    def __str__(self):
        return self.subject
```

### 2.4 其他事务部分
这部分内容有关其他事务的管理，主要包括通知、学习资料、评价、待办事项、管理员公告等功能。

### Notification

| 属性名                 | 数据类型 | 备注         |
| ---------------------- | -------- | ------------ |
| notification_id | int      | 主码、主属性 |
| user_id             | int      | 外码         |
| notification_date       | date     | -            |
| title       | varchar     | -            |
| description                | text     | -            |
| is_read                | boolean  | -            |

```python
# 通知表 BCNF   
class Notification(models.Model):
    # 主码、主属性
    notification_id = models.BigAutoField(primary_key=True)
    # 外码
    user_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='user_id_notice')
    notificationDate = models.DateTimeField(blank=True,null=True)
    title = models.CharField(max_length=255,blank=True,null=True)
    description = models.TextField(blank=True,null=True)
    is_read = models.BooleanField()

    def __str__(self):
        return self.title
    
    class Meta:
        ordering = ['-notificationDate']
        indexes = [
            models.Index(fields=['notification_date']),
        ]
```

### StudyMaterial

| 属性名      | 数据类型 | 备注         |
| ----------- | -------- | ------------ |
| material_id | int      | 主码、主属性 |
| tutor_id | int      | 外码         |
| student_id | int      | 外码         |
| file_name       | varchar     | -            |
| download_link       | varchar     | -            |
| upload_ate  | date     | -            |

```python
# 学习资料表 BCNF
class StudyMaterial(models.Model):
    # 主码、主属性
    material_id = models.BigAutoField(primary_key=True)
    # 外码
    tutor_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='tutor_id_material')
    # 外码
    student_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='student_id_material')
    file_name = models.CharField(max_length=255)
    download_link = models.CharField(max_length=255)
    upload_date = models.DateField()

    def __str__(self):
        return f"Material {self.material_id}"
    
    class Meta:
        ordering = ['-upload_date']
        indexes = [
            models.Index(fields=['upload_date']),
        ]
```

### Review

| 属性名     | 数据类型 | 备注         |
| ---------- | -------- | ------------ |
| review_id  | int      | 主码、主属性 |
| student_id | int      | 外码         |
| tutor_id   | int      | 外码         |
| rating     | int      | -            |
| content    | text     | -            |
| date    | date     | -            |

```python
# 评价表 BCNF
class Review(models.Model):
    # 主码、主属性
    review_id = models.BigAutoField(primary_key=True)
    # 外码
    student_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='student_id_review')
    # 外码
    tutor_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='tutor_id_review')
    rating = models.FloatField(blank=True,null=True)
    content = models.TextField(blank=True,null=True)
    date= models.DateField(blank=True,null=True)

    def __str__(self):
        return f"Review {self.review_id}"
    
    class Meta:
        ordering = ['-date']
        indexes = [
            models.Index(fields=['date']),
        ]
```

### Todo

| 属性名     | 数据类型 | 备注         |
| ---------- | -------- | ------------ |
| todo_id  | int      | 主码、主属性 |
| owner_id | int      | 外码         |
| accepter_id   | int      | 外码         |
| accepter_post_id   | int      | 外码         |
| is_completed     | int      | -            |

```python
# 待办事项表 BCNF
class Todo(models.Model):
    # 主码、主属性
    todo_id = models.BigAutoField(primary_key=True)
    # 外码
    owner_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='owner_id_todo')
    accepter_id = models.ForeignKey(User, on_delete=models.CASCADE,related_name='sender_id_todo')
    accept_post_id = models.ForeignKey(Post, on_delete=models.CASCADE,related_name='source_post_id_todo')
    is_completed = models.BooleanField()

    def __str__(self):
        return f"Todo {self.todo_id}"
```

### Announcement

| 属性名     | 数据类型 | 备注         |
| ---------- | -------- | ------------ |
| announcement_id  | int      | 主码、主属性 |
| announcement_date | date      | -         |
| title   | varchar      | -         |
| description   | text      | -         |

```python
class Announcement(models.Model):
    # 主码、主属性
    announcement_id = models.BigAutoField(primary_key=True)
    announcement_date = models.DateTimeField(blank=True,null=True)
    title = models.CharField(max_length=255,blank=True,null=True)
    description = models.TextField(blank=True,null=True)

    def __str__(self):
        return self.title
    
    class Meta:
        ordering = ['-announcement_date']
        indexes = [
            models.Index(fields=['announcement_date']),
        ]
```

## 三、系统重要功能实现

### 3.1 用户鉴权

我们参照现代网页前端设计，实现了token鉴权机制。当用户尝试进行登录时，服务端会鉴别用户身份并返回一个token。客户端会将这个token保存在cookie中。在登录成功后用户每次向服务端发出请求时都将附带上这个token。服务端可以依据校验该token，判断用户是否成功登录，并进一步获取用户的具体身份。用户鉴权的主要实现逻辑位于`frontend/src/utils/request.js`。

```javascript
// 用户登录成功后，调用该函数保存用户认证信息：保存用户token，以及设置token过期时间
function setAuthorization(auth) {
      Cookie.set(xsrfHeaderName, 'Bearer ' + auth.token, {expires: auth.expireAt})
}

// 用户退出登录后，调用该函数移除用户认证信息
function removeAuthorization() {
      Cookie.remove(xsrfHeaderName)
}
```

### 3.2 路由守卫

为了防止未获取权限的用户直接通过网址跳转到需要对应权限的页面，我们设计了全局路由守卫。即在用户进入每个页面之前都对用户的认证信息进行检测：如果检测通过，则跳转到对应页面；如果检测不通过，则跳转到错误处理页面。路由守卫主要处理逻辑位于`frontend/src/router/guards.js`中。

我们会在页面路由设置文件(`frontend/src/touter/config.js`)中规定进入相应页面所需的权限，如下所示：

```javascript
{
  path: 'announcementPage',   // 这是公告界面，所有登录用户均可查看
  name: '公告',
  meta: {
    icon: 'dashboard',
    page: {
      closable: false
    },
  },
  component: () => import('@/pages/announcementPage'),
},
{
  path: 'jobSeekPage', // 这是针对教师的求职页面
  name: "广场",
  meta: {
    icon: "team",
    authority: {
      role: 'teacher',     // 设置该页面只有role为'teacher'的用户才能进入
    }
  },
  component: () => import('@/pages/jobSeekPage')
},
{
  path : "hirePage", // 这是针对学生的招聘页面
  name: "广场",
  meta: {
    icon: "team",
    authority: {
      role: 'student'     // 设置该页面只有role为'student'的用户才能进入
    }
  },
  component: () => import('@/pages/hirePage')
}
```

当用户尝试进入某个页面时，首先会经过登录守卫的检测

```javascript
const loginGuard = (to, from, next, options) => {
  const {message} = options
  if (!loginIgnore.includes(to) && !checkAuthorization()) {
    message.warning('登录已失效，请重新登录')   // 鉴权失败，重定向到登录界面
    next({path: '/login'})
  } else {
    next()    // 鉴权成功，跳转到目标界面
  }
}
```

用户通过登录守卫验证，表示用户已经成功登录。之后用户还需要经过权限守卫的检测

```javascript
const authorityGuard = (to, from, next, options) => {
  const {store, message} = options
  const roles = store.getters['account/roles']
  if (!hasAuthority(to, roles)) {
    message.warning(`对不起，您无权访问页面: ${to.fullPath}，请联系管理员`)  // 鉴权失败，跳转到错误处理页面
    next({path: '/403'})
    // NProgress.done()
  } else {
    next()  // 鉴权成功，跳转到目标页面
  }
}

// 检测用户是否具有role权限
function hasAuthority(route, roles) {
  const authorities = [...route.meta.pAuthorities, route.meta.authority]
  for (let authority of authorities) {
    if (!hasRole(authority, roles)) {
      return false
    }
  }
  return true
}

// 检测用户的roles列表中是否含有页面所需的role权限
function hasRole(authority, roles) {
  let required = undefined
  if (typeof authority === 'object') {
    required = authority.role
  }
  return hasAnyItem(required, roles, (r, t) => !!(r === t || r === t.id))
}
```

用户通过权限守卫，表示用户拥有目标页面所需的权限。

用户通过登录守卫与权限守卫后，即可进入目标页面。

### 3.3 动态路由匹配

我们有时需要把某种模式匹配到的所有路由全都映射到同样的组件中。例如**学生主页**页面，**家教主页**页面，**帖子详情**页面，这时我们可以采用动态路由匹配：一组页面的组件设计相同，客户端通过具体指定的参数来决定具体跳转的目标页面。如下所示：

```javascript
{
    path: 'user/studentHomePage/:id',
    name: '学生主页',
    meta: {
    invisible: true
    },
    component: () => import('@/pages/studentHomePage')
}
```

在“学生主页”页面中，我们使用了动态路由参数，该页面的具体路径将由`$route.params.id`决定。

当我们需要跳转到`id`为`22373090`的页面时，可以这么编写代码

```javascript
this.$router.push({ name: '学生主页', params: { id: "22373090" } })
```

动态路由参数通过`route`直接获取

```javascript
userId: this.$route.params.id // 获取路由参数中的id
```

页面的具体信息可以通过`api`从服务端调取

```javascript
created() {    // 创建“学生主页”页面时，调用fetchUserInfo获取用户信息
    this.fetchUserInfo();
},
methods: {
    fetchUserInfo() {
        // 调用 getUserInfo api，获取用户信息
        getStudentInfo(this.userId)
            .then(response => {
                // ...
            })
            .catch(error => {
                // ...
            });
    }
}
```

具体实现效果如下

![](..\picture\动态路由示例.png)

### 3.4 文件上传

在我们使用的Vue2中，文件需要包装在`FormData`对象的`file`段中，才能与后端进行通信。如果此外还有其它数据，可以以`json`的形式包装在`FormData`对象的`data`段中，如下所示

```javascript
submitLearningMaterial() {
    const formData = new FormData();
    formData.append('file', this.fileList[0]);   // 将文件添加到formData的file段
    const jsonData = {
        id: this.currUser.id,
        teacher: this.currUser.name,
        studentId: this.curStudentId,
    };
    formData.append('data', JSON.stringify(jsonData));  // 将其他数据以json形式添加到data段中

    submitLearningMaterial(formData).then(res => {   // 通过api与后端进行通信
        // ...
    }).catch(error => {
        // ...
    });
}
```

### 3.5 文件下载

为了实现对用户上传的头像/文件进行云端存储，我们使用了MinIO进行对象存储。

MinIO是一个对象存储解决方案，它提供了与Amazon Web Services S3兼容的API，并支持所有核心S3功能。使用文档参照[MinIO Windows中文文档](https://minio.org.cn/docs/minio/linux/index.html)

我们从华为云租借了服务器（120.46.1.4），并将MinIO部署在该服务器上。实现效果如下

![](..\picture\MinIO.png)

![](..\picture\MinIO_2.png)

我们还对上传文件以及下载文件的接口进行了包装，使其使用起来更加方便

```python
from minio import Minio

minio_url = "120.46.1.4:9000"
minio_access_key = "****"
minio_secret_key = "****"

def get_download_url(file_name, type) -> str:
    """
    获取文件名为file_name文件的下载链接
    @param file_name: 文件名称
    @param type: 文件类型
    """
    return "http://" + minio_url + "/zxb/" + type + "/" + file_name


class MinioClient:
    def __init__(self):
        self.client = Minio(endpoint=minio_url, access_key=minio_access_key, secret_key=minio_secret_key, secure=False)

    def upload_file(self, data, file_name, type)
    """
	上传文件
	@param data: 文件的二进制流数据
	@param file_name：文件存储在云端的名称
	@param type: 文件类型
	"""
```

我们可以调用`upload_file`上传文件，调用`get_download_url`获取文件的下载链接，使用示例如下

```python
def submitLearningMaterial(request):
    # ...
    file = request.FILES['file']  # 获取上传的文件
    file_name = file.name
    file_type = file_name.split('.')[-1]

    unique_file_name = f"{uuid.uuid4()}.{file_type}" # 使用uuid生成唯一文件名，避免文件名重复发生覆盖

    minio = MinioClient()
    file_data = file.read() # 获取文件的二进制数据
    minio.upload_file(file_data, unique_file_name, file_type) # 上传文件
    download_link = get_download_url(unique_file_name, file_type) # 获取下载链接
    
    # ...
```

我们通过这种设计，成功实现了”**学习资料**“以及”**用户头像**“相关功能。


### 3.7 存储过程
### 3.7.1 用户管理（注册/登录）
1. 用户注册

* **涉及的基本表**：`User`，`Student`，`Tutor`

* **过程描述**：检查用户是否被注册。如果未被注册，则将用户信息插入到User表中，再根据身份信息插入到Student或Tutor表中，并给用户发送一条注册成功的通知。值得注意的是，管理员账号只能由超级管理员手动添加，因此不会出现管理员注册的情况。
```python
@csrf_exempt
def register(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        username = body.get('name')
        password = body.get('password')
        role = body.get('role')
        try:
            # 检查用户是否已经存在
            user = User.objects.get(username=username)
            result={'data':{}}
            result['code'] = -1
            return JsonResponse(result)
        except User.DoesNotExist:
            # 创建用户
            user = User(username=username, 
                        password=password, 
                        identity=-1,
                        registration_date=datetime.now(pytz.timezone('Asia/Shanghai')))
            result={'data':{}}
            if role == "admin":
                raise Exception("管理员账号只能由超级管理员手动添加")
            elif role == "teacher":
                user.identity = 1
                user.save()
                tutor=Tutor(user_id=user)
                tutor.save()
                result['data']['roles']=[{'id': 'teacher'}]
            elif role == "student":
                user.identity = 2
                user.save()
                student=Student(user_id=user)
                student.save()
                result['data']['roles']=[{'id': 'student'}]
            else:
                raise Exception("未知身份")

            request.session['user_id'] = user.user_id
            sendNotice(user,"注册成功","欢迎加入家教综合服务平台！")

            result['code'] = 0
            result['data']['token']="Authorization:" + str(random.random())
            result['data']['id'] = str(user.user_id)
            return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

2. 用户登录
* **涉及的基本表**：`User`

* **过程描述**：检查用户是否存在，如果存在则返回用户的身份信息，否则返回错误信息。值得注意的是，后续有相关业务需要知道当前用户的身份，因此在登录成功后将用户的user_id存入session中。
```python
@csrf_exempt
def login(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        username = body.get('name') 
        password = body.get('password')
        result = {'data': {}}
        try:
            # 查询数据库中是否存在对应的用户
            user = User.objects.get(username=username, password=password)
            if user.identity == 0:
                result['data']['roles'] = [{'id': 'admin'}]
            elif user.identity == 1:
                result['data']['roles'] = [{'id': 'teacher'}]
            elif user.identity == 2:
                result['data']['roles'] = [{'id': 'student'}]
            else:
                raise Exception("未知身份")
            result['data']['id'] = str(user.user_id)

            request.session['user_id'] = user.user_id 

            # 登录成功
            result['code'] = 0
            result['data']['token'] = "Authorization:" + str(random.random())
            result['message'] = "登录成功"
        except User.DoesNotExist:
            # 用户不存在或密码错误
            result['code'] = -1
            result['message'] = "账户名或密码错误"
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

3. 重置密码
* **涉及的基本表**：`User`
* **过程描述**：检查用户是否存在，如果存在则将用户的密码重置为新密码，否则返回错误信息。
```python
def resetPassword(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        user_id=int(body.get('id'))
        user=User.objects.get(user_id=user_id)
        old_password=body.get('oldpassword')
        new_password=body.get('password')
        if user.password!=old_password:
            return JsonResponse({'code': -1, 'message': '密码错误'})
        user.password=new_password
        user.save()
        return JsonResponse({'code': 0})
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

### 3.7.2 帖子广场管理
1. 发帖

* **涉及的基本表**：`Post`，`PostSubject`

* **过程描述**：检查帖子的内容是否完整，如果不完整则返回错误信息。如果内容完整，则将帖子信息插入到Post表中，再将帖子的科目信息插入到PostSubject表中。
```python
@csrf_exempt
def sendPost(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        request_id=int(body.get('id'))
        title = body.get('data').get('title')
        startDate = body.get('data').get('startDate')
        endDate = body.get('data').get('endDate')
        subjects=body.get('data').get('subjects')
        location=body.get('data').get('location')
        fullLocation=body.get('data').get('fullLocation')
        telephoneNumber=body.get('data').get('telephoneNumber')
        email=body.get('data').get('emailAddress')
        content=body.get('data').get('content')
        is_complete = all([title, startDate, endDate, subjects, location, fullLocation, telephoneNumber, content])
        if not is_complete:
            return JsonResponse({'code': 0})
        
        try :
            user=User.objects.get(user_id=request_id)
        except User.DoesNotExist:
            return JsonResponse({'code': -1, 'message': '用户不存在'})
        
        if user.identity ==0:
            raise Exception("管理员不通过sendPost发帖")
        else:
            post=Post(
                user_id=user,
                title=title,
                postDate=datetime.now(pytz.timezone('Asia/Shanghai')),
                startDate=startDate,
                endDate=endDate,
                location=location,
                fullLocation=fullLocation,
                telephoneNumber=telephoneNumber,
                emailAddress=email,
                content=content,
                is_completed=True,
                is_approved=False,
            )
            post.save()

            postSubjects = [
                PostSubject(post_id=post, subject=subject)
                for subject in subjects
            ]
            PostSubject.objects.bulk_create(postSubjects)

            result={'data':{}}
            result['code'] = 0
            return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

2. 保存模板

* **涉及的基本表**：`Post`，`PostSubject`

* **过程描述**：将帖子内容保存为模板，如果用户已经有模板，则更新模板内容，否则新建一个模板。模板与帖子用is_completed字段区分。
```python
@csrf_exempt
def savePost(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        request_id=int(body.get('id'))
        title = body.get('data').get('title')
        startDate = body.get('data').get('startDate') or None
        endDate = body.get('data').get('endDate') or None
        subjects=body.get('data').get('subjects')
        location=body.get('data').get('location')
        fullLocation=body.get('data').get('fullLocation')
        telephoneNumber=body.get('data').get('telephoneNumber')
        email=body.get('data').get('emailAddress') or None
        content=body.get('data').get('content')

        try:
            user=User.objects.get(user_id=request_id)
        except User.DoesNotExist:
            return JsonResponse({'code': -1, 'message': '用户不存在'})
        
        if user.identity ==0:
            raise Exception("管理员无法保存帖子")
        else:
            try:
                post=Post.objects.get(user_id=user,is_completed=False)
                post.title=title
                post.startDate=startDate
                post.endDate=endDate
                post.location=location
                post.fullLocation=fullLocation
                post.telephoneNumber=telephoneNumber
                post.emailAddress=email
                post.content=content
                post.save()
                PostSubject.objects.filter(post_id=post).delete()
                postSubjects = [
                    PostSubject(post_id=post, subject=subject)
                    for subject in subjects
                ]
                PostSubject.objects.bulk_create(postSubjects)
                result={'data':{}}
                result['code'] = 0
                return JsonResponse(result)
            except Post.DoesNotExist:
                post=Post(
                    user_id=user,
                    title=title,
                    startDate=startDate,
                    endDate=endDate,
                    location=location,
                    fullLocation=fullLocation,
                    telephoneNumber=telephoneNumber,
                    emailAddress=email,
                    content=content,
                    is_completed=False,
                    is_approved=False,
                )
                post.save()
                postSubjects = [
                    PostSubject(post_id=post, subject=subject)
                    for subject in subjects
                ]
                PostSubject.objects.bulk_create(postSubjects)
                result={'data':{}}
                result['code'] = 0
                return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

3. 获取模板

* **涉及的基本表**：`Post`，`PostSubject`

* **过程描述**：获取用户的模板，如果用户没有模板，则返回空数据。  
```python
@csrf_exempt
def getSavedPost(request):
    if request.method == 'GET':
        try:
            user_id=request.GET.get('id')
            user=User.objects.get(user_id=int(user_id))
            if user.identity==0:
                raise Exception("管理员无法获取帖子")
            else:
                try:
                    post=Post.objects.get(user_id=user,is_completed=False)
                    result={'data':{}}
                    result['code'] = 0
                    result['data']['title']=post.title
                    result['data']['startDate']=post.startDate
                    result['data']['endDate']=post.endDate
                    location=post.location.strip('"')
                    location=json.loads(location.replace("'",'"'))
                    result['data']['location']=location
                    result['data']['fullLocation']=post.fullLocation
                    result['data']['telephoneNumber']=post.telephoneNumber
                    result['data']['emailAddress']=post.emailAddress
                    result['data']['content']=post.content
                    subjects=PostSubject.objects.filter(post_id=post)
                    result['data']['subjects']=[subject.subject for subject in subjects]
                except:
                    result={'data':{}}
                    result['code'] = 0
                return JsonResponse(result)
        except User.DoesNotExist:
            result={'data':{}}
            result['code'] = 0
            return JsonResponse(result)     
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

4. 在帖子广场上获取帖子

* **涉及的基本表**：`Post`，`PostSubject`

* **过程描述**：获取帖子广场上的帖子，并根据搜索关键词以及用户身份进行筛选。具体来说，首先学生只会看到家教发的帖子，家教会看到学生发的帖子，管理员会看到所有尚未审核的帖子。然后根据搜索关键词进行筛选，匹配字段包含科目、用户名、标题、内容、地址。如果搜索关键词为空，则返回所有符合条件的帖子。采用模糊匹配。
```python
@csrf_exempt
def getPosts(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        request_page=int(request.GET.get('page'))
        request_query=request.GET.get('query')
        start=(request_page-1)*10
        end=request_page*10
        returnSubjects=[]
        user=User.objects.get(user_id=request_id)
        try:
            if user.identity==1:
                filter_id=2
            else:
                filter_id=1
            
            if request_query=="":
                if user.identity!=0:
                    posts=Post.objects.filter(is_completed=True,user_id__identity=filter_id,is_approved=True)
                else:
                    posts=Post.objects.filter(is_completed=True,is_approved=False)
            else:
                all_posts = Post.objects.all()
                matching_posts = []
                for post in all_posts:
                    subjects=PostSubject.objects.filter(post_id=post).values_list('subject', flat=True)
                    subjects_str = ' '.join(subjects)
                    username_str = post.user_id.username
                    title_str = post.title
                    content_str = post.content
                    location_str = post.location.strip('"')
                    location_list = json.loads(location_str.replace("'", '"'))
                    location_str = ' '.join(location_list) if isinstance(location_list, list) else location_str
                    long_str = f"{subjects_str} {username_str} {title_str} {content_str} {location_str}".lower()
                    
                    request_query = request_query.lower()
                    if request_query in long_str:
                        matching_posts.append(post)
                if user.identity != 0:
                    posts = [post for post in matching_posts if post.is_completed and post.user_id.identity == filter_id and post.is_approved]
                else:
                    posts = [post for post in matching_posts if post.is_completed and not post.is_approved]
            
            return_posts=[]
            for post in posts:
                user=post.user_id
                now = datetime.now(pytz.timezone('Asia/Shanghai'))
                post_date = post.postDate.astimezone(pytz.timezone('Asia/Shanghai'))
                time_diff = now - post_date
                if time_diff < timedelta(hours=24):
                    date_display = f"{time_diff.seconds // 3600}小时前"
                elif time_diff < timedelta(days=3):
                    date_display = f"{time_diff.days}天前"
                else:
                    date_display = post_date.strftime("%Y-%m-%d")
                return_subject_lines=PostSubject.objects.filter(post_id=post)
                returnSubjects=[]
                returnSubjects = [subject.subject for subject in return_subject_lines]
                location=post.location.strip('"')
                location=json.loads(location.replace("'",'"'))
                location=location[0]
                return_posts.append({
                    'id':str(post.post_id),
                    'title':post.title,
                    'tags':returnSubjects,
                    'content':post.content,
                    'author':user.username,
                    'authorId':user.user_id,
                    'date':date_display,
                    'location':location,
                })
            result={'posts':return_posts[start:end],'total':len(posts)}
            return JsonResponse(result)
        except User.DoesNotExist:
            raise Exception("用户不存在")
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```


5. 获取用户所发的帖子
* **涉及的基本表**：`Post`，`PostSubject`
* **过程描述**：根据帖子id直接获取帖子内容，如果帖子不存在则返回错误信息。
```python
@csrf_exempt
def getPost(request):
    if request.method == 'GET':
        post_id=int(request.GET.get('id'))
        try:
            post=Post.objects.get(post_id=post_id)
            result={'data':{}}
            result['code'] = 0
            result['data']['title']=post.title
            result['data']['author']=post.user_id.username
            location=post.location.strip('"')
            location=json.loads(location.replace("'",'"'))
            result['data']['location']=location
            result['data']['fullLocation']=post.fullLocation
            result['data']['telephoneNumber']=post.telephoneNumber
            result['data']['emailAddress']=post.emailAddress
            result['data']['startDate']=post.startDate
            result['data']['endDate']=post.endDate
            subject_lines=PostSubject.objects.filter(post_id=post)
            subjects=[]
            subjects = [subject.subject for subject in subject_lines]
            result['data']['subjects']=subjects
            result['data']['content']=post.content
            return JsonResponse(result)
            
        except Post.DoesNotExist:
            return JsonResponse({'code': -1, 'message': '帖子不存在'})
```

### 3.7.3 师生个人信息管理
1. 更新学生信息
* **涉及的基本表**：`Student`
* **过程描述**：更新学生的个人信息。
```python
@csrf_exempt
def updateStudentInfo(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        request_id=int(body.get('id'))
        grade = body.get('data').get('grade')
        gender = body.get('data').get('gender')
        age=body.get('data').get('age')
        email=body.get('data').get('email')
        telephone=body.get('data').get('telephone')
        address=body.get('data').get('address')
        intro=body.get('data').get('intro')
        personalSignature=body.get('data').get('personalSignature')

        user=User.objects.get(user_id=request_id)
        student=Student.objects.get(user_id=user)
        student.grade=grade
        student.gender=gender
        student.age=age
        student.email=email
        student.telephone=telephone
        student.address=address
        student.intro=intro
        student.personalSignature=personalSignature
        student.save()

        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

2. 获取学生信息
* **涉及的基本表**：`Student`
* **过程描述**：获取学生的个人信息。
```python
@csrf_exempt
def getStudentInfo(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        result={'data':{}}
        result['code'] = 0
        user=User.objects.get(user_id=request_id)
        student=Student.objects.get(user_id=user)
        result['data']['name']=user.username
        result['data']['email']=student.email
        result['data']['telephone']=student.telephone
        result['data']['address']=student.address
        result['data']['personalSignature']=student.personalSignature
        result['data']['intro']=student.intro
        result['data']['age']=student.age
        result['data']['gender']=student.gender
        result['data']['grade']=student.grade
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

3. 更新家教信息
* **涉及的基本表**：`Tutor`
* **过程描述**：更新家教的个人信息。
```python
@csrf_exempt
@csrf_exempt
def updateTeacherInfo(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        request_id=int(body.get('id'))
        degree=body.get('data').get('degree')
        gender=body.get('data').get('gender')
        age=body.get('data').get('age')
        email=body.get('data').get('email')
        telephone=body.get('data').get('telephone')
        address=body.get('data').get('address')
        intro=body.get('data').get('intro')
        personalSignature=body.get('data').get('personalSignature')

        user=User.objects.get(user_id=request_id)
        tutor=Tutor.objects.get(user_id=user)
        tutor.degree=degree
        tutor.gender=gender
        tutor.age=age
        tutor.email=email
        tutor.telephone=telephone
        tutor.address=address
        tutor.intro=intro
        tutor.personalSignature=personalSignature
        tutor.save()

        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

4. 获取家教信息
* **涉及的基本表**：`Tutor`
* **过程描述**：获取家教的个人信息。注意在评论区需要获取评论学生的头像，如果学生没有头像则使用默认头像。
```python
@csrf_exempt
def getTeacherInfo(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))

        result={'data':{}}
        result['code'] = 0
        user=User.objects.get(user_id=request_id)
        tutor=Tutor.objects.get(user_id=user)
        result['data']['name']=user.username
        result['data']['email']=tutor.email
        result['data']['telephone']=tutor.telephone
        result['data']['address']=tutor.address
        result['data']['personalSignature']=tutor.personalSignature
        result['data']['intro']=tutor.intro
        result['data']['gender']=tutor.gender
        result['data']['age']=tutor.age
        result['data']['degree']=tutor.degree
        result['data']['rate']=round(tutor.rate,1)
        result['data']['rateNum']=tutor.rateNum
        comments=Review.objects.filter(tutor_id=user)
        return_comments=[]
        for comment in comments:
            return_comments.append({
                'id':str(comment.review_id),
                'authorName':comment.student_id.username,
                'rating':comment.rating,
                'content':comment.content,
                'date':comment.date,
                'avatar':comment.student_id.avatar if comment.student_id.avatar else 'http://120.46.1.4:9000/zxb/png/Akkarin.png',
            })
        result['data']['comments']=return_comments
        print(result)
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

5. 更新头像
* **涉及的基本表**：`User`
* **过程描述**：更新用户的头像。注意为了避免图片重名，我们使用uuid生成唯一文件名，将文件上传至容器后，将访问链接保存至数据库中。
```python
def uploadAvatar(request):
    if request.method == 'POST':
        id_request=json.loads(request.POST.get('data'))
        # 使用 request.POST 和 request.FILES 解析 FormData 对象
        user_id = int(id_request.get('id'))
        file = request.FILES['file']  # 获取上传的文件
        file_name = file.name
        file_type = file_name.split('.')[-1]

        unique_file_name = f"{uuid.uuid4()}.{file_type}"

        try:
            user = User.objects.get(user_id=user_id)
        except User.DoesNotExist:
            return JsonResponse({'code': 1, 'message': '用户不存在'})

        # 使用 MinioClient 上传文件并获取下载链接
        minio_client = MinioClient()
        file_data = file.read()
        try:
            minio_client.upload_file(file_data, unique_file_name, file_type)
            download_link = get_download_url(unique_file_name, file_type)
        except ValueError as e:
            return JsonResponse({'code': 1, 'message': str(e)})

        # 更新用户头像链接
        user.avatar = download_link
        user.save()

        result = {'code': 0, 'message': ''}
        return JsonResponse(result)
    else:
        return JsonResponse({'code': 1, 'message': '仅支持POST请求'})
```

6. 获取头像
* **涉及的基本表**：`User`
* **过程描述**：获取用户的头像。如果用户没有头像，则使用默认头像。
```python
def getAvatar(request):
    if request.method == 'GET':
        user_id = int(request.GET.get('id'))
        try:
            user = User.objects.get(user_id=user_id)
        except User.DoesNotExist:
            return JsonResponse({'code': 1, 'message': '用户不存在'})

        if user.avatar:
            avatar_url = user.avatar
        else:
            avatar_url = 'http://120.46.1.4:9000/zxb/png/Akkarin.png'
        print(avatar_url)
        result = {'code': 0, 'avatar': avatar_url}
        print(result)
        return JsonResponse(result)
    else:
        return JsonResponse({'code': 1, 'message': '仅支持GET请求'})
```


### 3.7.4 个人工作管理
1. 获取本人发布的所有帖子
* **涉及的基本表**：`Post`，`PostSubject`
* **过程描述**：获取用户发布的所有帖子。注意，有别于帖子广场，未经审核的帖子也会在这里显示。
```python
def getUserPosts(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        user=User.objects.get(user_id=request_id)
        posts=Post.objects.filter(user_id=user,is_completed=True)

        return_posts=[]
        result={}
        result['code'] = 0
        for post in posts:
            return_posts.append({
                'id':str(post.post_id),
                'title':post.title,
                'content':post.content,
            })
        result['posts']=return_posts
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

2. 删除自己发布的帖子
* **涉及的基本表**：`Post`，`PostSubject`
* **过程描述**：用户可以自行删除自己发布的帖子。
```python
def deletePost(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        post_id=int(body.get('postId'))
        post=Post.objects.get(post_id=post_id)
        post.delete()
        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

3. 家教获取自己的所有学生
* **涉及的基本表**：`Link`
* **过程描述**：家教可以获取自己的所有学生。
```python
def getStudents(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        students=Link.objects.filter(tutor_id=request_id)
        return_students=[]
        result={}
        result['code'] = 0
        for student in students:
            return_students.append({
                'id':str(student.student_id.user_id),
                'name':student.student_id.username,
            })
        result['students']=return_students
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

4. 学生获取自己的家教
* **涉及的基本表**：`Link`
* **过程描述**：学生可以获取自己的家教。
```python
def getTutors(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        tutors=Link.objects.filter(student_id=request_id)
        return_tutors=[]
        result={}
        result['code'] = 0
        for tutor in tutors:
            return_tutors.append({
                'id':str(tutor.tutor_id.user_id),
                'name':tutor.tutor_id.username,
            })
        result['tutors']=return_tutors
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

5. 发送通知
* **涉及的基本表**：`Notification`
* **过程描述**：用户在执行相关工作后，会发送信息给涉及到的其他用户。这是一个工具方法，前端并不会直接调用这一api。
```python
def sendNotice(user,title,description):
    notification=Notification(
        user_id=user,
        notificationDate=datetime.now(pytz.timezone('Asia/Shanghai')),
        title=title,
        description=description,
        is_read=False,
        )
    notification.save()
```

6. 获取通知
* **涉及的基本表**：`Notification`
* **过程描述**：用户可以获取自己的通知。
```python
def getNotices(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        user=User.objects.get(user_id=request_id)
        notifications=Notification.objects.filter(user_id=user)

        return_notifications=[]
        result={'data':{}}
        result['code'] = 0
        for notification in notifications:
            return_notifications.append({
                'title':notification.title,
                'description':notification.description,
            })
        result['data']['notices']=return_notifications
        new_len=len(Notification.objects.filter(user_id=user,is_read=False))
        Notification.objects.filter(user_id=user).update(is_read=True)
        result['data']['newNum']=new_len
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

7. 完成待办事项以建立师生关系
* **涉及的基本表**：`Todo`，`Link`
* **过程描述**：家教和学生通过完成待办事项建立关系。
```python
def link(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        tutor_id=int(body.get('teacherId'))
        student_id=int(body.get('studentId'))
        tutor=User.objects.get(user_id=tutor_id)
        student=User.objects.get(user_id=student_id)

        link=Link(tutor_id=tutor,student_id=student)
        link.save()

        user_id=request.session['user_id']
        if user_id==tutor_id:
            sendNotice(student,"招聘成功",f"您正式成为{tutor.username}的学生")
            todos=Todo.objects.filter(owner_id=tutor,accepter_id=student)
            for todo in todos:
                todo.delete()
        else:
            sendNotice(tutor,"应聘成功",f"您正式成为{student.username}的家教")
            todos=Todo.objects.filter(owner_id=student,accepter_id=tutor)
            for todo in todos:
                todo.delete()

        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

8. 拒绝待办事项
* **涉及的基本表**：`Todo`
* **过程描述**：家教和学生通过拒绝待办事项拒绝建立关系。
```python
def refuseLink(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        tutor_id=int(body.get('teacherId'))
        student_id=int(body.get('studentId'))
        tutor=User.objects.get(user_id=tutor_id)
        student=User.objects.get(user_id=student_id)

        user_id=request.session['user_id']
        if user_id==tutor_id:
            sendNotice(student,"招聘失败",f"很抱歉，{tutor.username}未同意您的招聘")
            todos=Todo.objects.filter(owner_id=tutor,accepter_id=student)
            for todo in todos:
                todo.delete()
        else:
            sendNotice(tutor,"应聘失败",f"很抱歉，{student.username}未同意您的应聘")
            todos=Todo.objects.filter(owner_id=student,accepter_id=tutor)
            for todo in todos:
                todo.delete()

        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

9. 取消师生关系
* **涉及的基本表**：`Link`
* **过程描述**：家教和学生通过取消师生关系解除关系。
```python
def unlink(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        print(body)
        tutor_id=int(body.get('id'))
        student_id=int(body.get('studentId'))
        tutor=User.objects.get(user_id=tutor_id)
        student=User.objects.get(user_id=student_id)

        link=Link.objects.get(tutor_id=tutor,student_id=student)
        link.delete()

        user_id=request.session['user_id']
        if user_id==tutor_id:
            sendNotice(student,"解除招聘",f"您已经不再是{tutor.username}的学生")
        else:
            sendNotice(tutor,"解除应聘",f"您已经不再是{student.username}的家教")

        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

10.  学生给家教评价
* **涉及的基本表**：`Review`
* **过程描述**：学生给家教评价。
```python
def submitComment(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        student_id=int(body.get('studentId'))
        tutor_id=int(body.get('teacherId'))
        rating=int(body.get('rate'))
        comment=body.get('comment')
        user=User.objects.get(user_id=student_id)
        tutor=User.objects.get(user_id=tutor_id)
        teacher=Tutor.objects.get(user_id=tutor)
        if teacher.rateNum!=0:
            rate_sum=teacher.rate*teacher.rateNum
        else:
            rate_sum=0
        old_review=Review.objects.get(student_id=user,tutor_id=tutor)
        if old_review:
            teacher.rateNum-=1
            rate_sum-=old_review.rating  
            old_review.delete()
        review=Review(
            student_id=user,
            tutor_id=tutor,
            rating=rating,
            content=comment,
            date=datetime.now(pytz.timezone('Asia/Shanghai')),
        )
        review.save()

        sendNotice(tutor,"收到新评价",f"您收到了来自{user.username}的新评价")
        teacher.rateNum+=1
        rate_sum+=rating
        teacher.rate=rate_sum/teacher.rateNum
        teacher.save()
        
        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'}) 
```

11.  家教给学生上传学习资料
* **涉及的基本表**：`StudyMaterial`
* **过程描述**：家教给学生上传学习资料。为避免重名文件发生覆盖，这里在上传容器前使用uuid生成唯一文件名，然后将文件名和下载链接存入数据库。
```python
def submitLearningMaterial(request):
    if request.method == 'POST':
        body = json.loads(request.POST.get('data'))
        tutor_id = int(body.get('id'))
        student_id = int(body.get('studentId'))
        file = request.FILES['file']  # 获取上传的文件
        file_name = file.name
        file_type = file_name.split('.')[-1]
        user=User.objects.get(user_id=student_id)
        tutor=User.objects.get(user_id=tutor_id)

        unique_file_name = f"{uuid.uuid4()}.{file_type}"

        minio = MinioClient()
        file_data = file.read()
        minio.upload_file(file_data, unique_file_name, file_type)
        download_link = get_download_url(unique_file_name, file_type)

        material=StudyMaterial(
            tutor_id=tutor,
            student_id=user,
            file_name=file_name,
            download_link=download_link,
            upload_date=datetime.now(pytz.timezone('Asia/Shanghai')),
        )
        material.save()
        sendNotice(user,"收到新学习资料",f"您收到了来自{tutor.username}的新学习资料")
        result={'data':{}}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

12.  学生获取学习资料
* **涉及的基本表**：`StudyMaterial`
* **过程描述**：学生获取家教上传的学习资料。
```python
def getLearningMaterials(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        user=User.objects.get(user_id=request_id)
        materials=StudyMaterial.objects.filter(student_id=user)

        return_materials=[]
        result={}
        result['code'] = 0
        for material in materials:
            return_materials.append({
                'id':str(material.material_id),
                'filename':material.file_name,
                'publisher':material.tutor_id.username,
                'downloadLink':material.download_link,
                'date':material.upload_date,
            })
        result['materials']=return_materials
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

13.  发送待办事项
* **涉及的基本表**：`Todo`
* **过程描述**：用户在执行相关工作后，会发送待办事项给涉及到的其他用户。这是一个工具方法，前端并不会直接调用这一api。
```python
def sendTodo(user,post,accepter):
    todo=Todo(
        owner_id=user,
        accepter_id=accepter,
        accept_post_id=post,
        is_completed=False,
    )
    todo.save()
```

14.  获取待办事项
* **涉及的基本表**：`Todo`
* **过程描述**：用户可以获取自己的待办事项。
```python
def getTodos(request):
    if request.method == 'GET':
        request_id=int(request.GET.get('id'))
        user=User.objects.get(user_id=request_id)
        todos=Todo.objects.filter(owner_id=user)

        return_todos=[]
        result={}
        result['code'] = 0
        for todo in todos:
            return_todos.append({
                'id':str(todo.todo_id),
                'postId':str(todo.accept_post_id.post_id),
                'postTitle':todo.accept_post_id.title,
                'accepterName':todo.accepter_id.username,
                'accepterId':str(todo.accepter_id.user_id),
            })
        result['todos']=return_todos
        print(result)
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

15. 获取站点公告
* **涉及的基本表**：`Announcement`
* **过程描述**：用户可以获取站点公告。
```python
def getAnnouncements(request):
    if request.method == 'GET':
        try:
            return_announcements=[]
            for announcement in Announcement.objects.all():
                now = datetime.now(pytz.timezone('Asia/Shanghai'))
                announcement_date = announcement.announcementDate.astimezone(pytz.timezone('Asia/Shanghai'))
                time_diff = now - announcement_date
                if time_diff < timedelta(hours=24):
                    date_display = f"{time_diff.seconds // 3600}小时前"
                elif time_diff < timedelta(days=3):
                    date_display = f"{time_diff.days}天前"
                else:
                    date_display = announcement_date.strftime("%Y-%m-%d")
                return_announcements.append({
                    'title':announcement.title,
                    'content':announcement.description,
                    'date':date_display,
                })
            result={'data':{}}
            result['code'] = 0
            result['data']['announcements']=return_announcements
            return JsonResponse(result)
        except User.DoesNotExist:
            raise Exception("用户不存在")
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```


### 3.7.5 管理员事务管理
1. 获取用户身份
* **涉及的基本表**：`User`
* **过程描述**：管理员可以获取用户的身份。
```python
def getUserRole(request):
    if request.method == 'GET':
        post_id=int(request.GET.get('id'))
        post=Post.objects.get(post_id=post_id)
        user=post.user_id
        result={'data':{}}
        result['code'] = 0
        if user.identity==0:
            raise Exception("管理员不发帖子")
        elif user.identity==1:
            result['data']['userRole']="家教"
        else:
            result['data']['userRole']="学生"
        print(result)
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

2. 审核通过帖子
* **涉及的基本表**：`Post`
* **过程描述**：管理员可以审核通过帖子。
```python
def approvePost(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        print(body)
        post_id=int(body.get('postId'))
        post=Post.objects.get(post_id=post_id)
        post.is_approved=True
        post.save()
        sendNotice(post.user_id,"帖子通过审核",f"您的帖子《{post.title}》已通过审核")
        result={}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

3. 审核拒绝帖子
* **涉及的基本表**：`Post`
* **过程描述**：管理员可以审核拒绝帖子。
```python
def rejectPost(request):
    if request.method == 'POST':
        body = json.loads(request.body)5.
        post_id=int(body.get('postId'))
        post=Post.objects.get(post_id=post_id)
        post.delete()
        sendNotice(post.user_id,"帖子未通过审核",f"您的帖子《{post.title}》未通过审核")
        result={}
        result['code'] = 0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

4. 获取所有家教
* **涉及的基本表**：`Tutor`
* **过程描述**：管理员可以获取所有家教。
```python
def getAllTeachers(request):
    if request.method == 'GET':
        teachers=User.objects.filter(identity=1)
        return_teachers=[]
        result={}
        result['code'] = 0
        for teacher in teachers:
            return_teachers.append({
                'id':str(teacher.user_id),
                'name':teacher.username,
            })
        result['teachers']=return_teachers
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

5. 获取所有学生
* **涉及的基本表**：`Student`
* **过程描述**：管理员可以获取所有学生。
```python
def getAllStudents(request):
    if request.method == 'GET':
        students=User.objects.filter(identity=2)
        return_students=[]
        result={}
        result['code'] = 0
        for student in students:
            return_students.append({
                'id':str(student.user_id),
                'name':student.username,
            })
        result['students']=return_students
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持GET请求'})
```

6. 发表站点公告
* **涉及的基本表**：`Announcement`
* **过程描述**：管理员可以发表站点公告。
```python
def makeAnnouncement(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        title=body.get('title')
        content=body.get('content')
        announcement=Announcement(
              title=title,
              description=content,
              announcementDate=datetime.now(pytz.timezone('Asia/Shanghai')),
        )
        announcement.save()
        result={}
        result['code']=0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

7. 删除用户
* **涉及的基本表**：`User`
* **过程描述**：管理员可以删除用户。
```python
def deleteUser(request):
    if request.method == 'POST':
        body = json.loads(request.body)
        user_id=int(body.get('id'))
        user=User.objects.get(user_id=user_id)
        user.delete()
        result={}
        result['code']=0
        return JsonResponse(result)
    else:
        return JsonResponse({'code': -1, 'message': '仅支持POST请求'})
```

## 四、系统实现效果

### 4.1 登录注册

#### 4.1.1 登录

![](..\picture\登录界面_1.png#pic_center)

进入网站，或者在未登录的情况下访问网站页面都将跳转到首页，在这个页面用户可以进行登录，输入正确的用户名以及密码即可登录成功。

#### 4.1.2 注册

![](..\picture\登录界面_2.png)

用户可以在首页的标签页进行注册。填写用户名、密码，以及确认密码、身份之后即可成功注册。本系统的管理员账号由后端分配，不可直接注册。

#### 4.1.3 退出登录

![](..\picture\退出登录.png)

在登录成功后的主页面中，点击右上角的用户名可以展开下属的选择框可以选择退出登录。随后页面便会删除当前用户的登录认证信息。用户将会跳转到登录页面。

#### 4.1.4 修改密码

![](..\picture\修改密码.png)

在相同的选择框中可以选择**修改密码**，之后便会弹出修改密码对话框。

![](..\picture\修改密码_2.png)

在经过前端验证“新密码”和“确认密码”一致、后端验证旧密码一致后即可修改密码。之后页面将会删除当前用户的登录认证信息。用户将会跳转到登录界面。

### 4.2 个人主页

![](..\picture\选择个人主页.png)

在登录成功后的主页面中，点击右上角的用户名可以展开下属的选择框可以选择**个人主页**以查看个人主页。对于学生和家教两种不同的身份，个人主页的展示内容有所不同，主要区别在于是否有评论展示区以及评分展示区。

#### 4.2.1 学生个人主页

![](..\picture\学生个人主页.png)

学生个人主页按照从上到下，从左到右的顺序展示姓名、个性签名、性别、年龄、年级、邮箱、电话、地址、以及个人简介。

#### 4.2.2 家教个人主页

![](..\picture\教师个人主页.png)

家教个人主页按照从上到下，从左到右的顺序展示姓名、个性签名、评分、评分人数、性别、年龄、学历、邮箱、电话、地址、个人简介以及用户评论。

#### 4.2.3 编辑个人主页

![](..\picture\选择编辑个人主页.png)

在用户名下属的选择框中选择**编辑个人主页**可以对个人主页信息进行编辑。

![](..\picture\编辑个人主页_家教.png)

![](..\picture\编辑个人主页_学生.png)

学生和家教的”编辑个人主页“页面大致相同。唯一的区别在于家教页面的”学历“一栏，在学生页面中显示为”年级“。

### 4.3 消息通知

![](..\picture\通知.png)

点击顶栏的”闹钟“图标即可展开通知。当发生”帖子通过审核“”有新的公告“”家教发布学习资料“”请求建立师生关系“”成功建立师生关系“等多种情况时都会产生通知信息，以便用户及时获取重要信息。

### 4.4 侧边栏

![](..\picture\侧边栏.png)

在每个页面的左侧都存在侧边栏，用户可以在侧边栏中选择页面进行跳转。对于不同的身份（学生，家教，管理员），侧边栏包含的页面不同。公有的页面为“公告”与“广场”。学生独有的页面为“我要招聘”和“我的学习”。家教独有的页面为“我要求聘”和“我的工作”。管理员页面独有的页面为“用户管理”与“发布公告”。

### 4.5 公告

#### 4.5.1 查看公告

![](..\picture\公告页.png)

在登录成功或者注册成功后用户会跳转到**公告页面**，在欢迎信息之下便是公告展示框，用户可以对公告标题进行点击以选择需要查看的公告内容。

#### 4.5.2 发布公告

![](..\picture\发布公告.png)

在用户以管理员身份登入后，可以在侧边栏选择”**发布公告**“跳转到发布公告界面。在该界面管理员可以填写公告的内容并进行发布。

### 4.6 广场

#### 4.6.1 帖子检索

![](..\picture\广场.png)

用户可以在侧边栏中选择跳转到**广场页面**。在广场页面，不同的角色所看到的帖子不同。学生可以看到家教们发的求聘帖；家教可以看到学生们发的招聘帖；管理员可以看到所有帖子。

![](..\picture\翻页.png)

网页每次至多加载10篇帖子。用户需要点击页面下方的页码去查看更多的帖子。这样的设计可以使用户界面更加简介，同时减少网页负担。

![](..\picture\帖子点击示例.png)

对于每个帖子，点击作者名（蓝字部分）即可查看作者的个人主页，点击除此之外的任意部分即可查看帖子详情。

![](..\picture\搜索.png)

广场页面的最上方存在搜索框，提供搜索功能，并支持基本的模糊搜索（搜索“北”字，可以检索出所有内容包含“北”字的帖子）

#### 4.6.2 帖子详情

![](..\picture\帖子详情.png)

![](..\picture\帖子详情_2.png)

在广场页面点击帖子即可跳转到**帖子详情**页面，在该页面家教（学生）可以选择接受“**招聘**“（”**求聘**“），管理员可以选择“**通过**”或者“**驳回**”该帖子。只有管理员审核通过的帖子才会进入广场页面。

### 4.7 发帖界面

![](..\picture\发帖界面.png)

学生（家教）用户可以通过在侧边栏选择“**我要招聘（我要求聘）**”跳转到发帖界面。在这个页面用户可以填写自己的基本信息以及需求，并可以对已填写内容进行保存和提交。提交后的帖子经管理员审核通过后便会出现在广场界面。

### 4.8 学生学习界面

![](..\picture\我的学习标签页.png)

学生用户可以通过点击左边侧边栏“**我的学习**”进入学生学习界面。在该界面用户可以通过切换标签页进入“我的帖子”“我的家教”“我的待办”“我的学习资料”四个小标签页。

#### 4.8.1 我的帖子

![](..\picture\我的帖子.png)

![](..\picture\我的帖子_2.png)

在“我的帖子”小标签页中，用户可以浏览自己发布过的帖子，选择查看帖子详情或者删除帖子。

#### 4.8.2 我的家教

![](..\picture\我的家教.png)

![](..\picture\我的家教_2.png)

在“我的家教”小标签页中，学生用户可以查看自己的家教，浏览家教主页，对家教发表评价或者解除师生关系。

![](..\picture\发表评价.png)

在用户点击“发表评价”后，页面右侧将会弹出抽屉以供用户填写评价具体信息。用户提交的评价将会出现在对应家教的个人主页上。

#### 4.8.3 我的待办

![](..\picture\我的待办.png)

在"我的待办"小标签页中，用户可以浏览自己的待办事项，并选择接受或者拒绝。

![](..\picture\我的待办_2.png)

待办事项中的蓝色部分为可跳转链接。以上图为例，当用户点击红框后，页面将分别跳转到对应的帖子详情页面和

对应的家教主页。

#### 4.8.4 我的学习资料

![](..\picture\我的学习资料.png)

在"我的学习资料"小标签页中，学生用户可以查看家教发布的学习资料，并选择进行下载。

### 4.9 家教工作界面

![](..\picture\我的工作.png)

家教的“**我的工作**”界面与学生的“**我的学习**”界面界面大致相同，区别在于家教在”我的学生“标签页下存在”发布学习资料“按钮。

![](..\picture\发布学习资料.png)

在该界面家教可以填写需要上传学习资料，以供学生进行下载。

### 4.10 用户管理

![](..\picture\用户管理.png)

![](..\picture\用户管理_2.png)

在用户以管理员身份登入后，用户可以点击侧边栏的”**用户管理**“按钮进入”用户管理“界面。在该界面，管理员可以查看所有用户的信息并删除用户（将用户加入黑名单）。
